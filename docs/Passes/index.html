<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Passes - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Passes/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Passes</h1><p>This document describes the available CIRCT passes and their contracts.</p><p><nav id=TableOfContents><ul><li><a href=#conversion-passes>Conversion Passes</a><ul><li><a href=#-convert-affine-to-staticlogic-convert-affine-dialect-to-staticlogic-pipelines>-convert-affine-to-staticlogic: Convert Affine dialect to StaticLogic pipelines</a></li><li><a href=#-convert-hw-to-llhd-convert-hw-to-llhd>-convert-hw-to-llhd: Convert HW to LLHD</a></li><li><a href=#-convert-llhd-to-llvm-convert-llhd-to-llvm>-convert-llhd-to-llvm: Convert LLHD to LLVM</a></li><li><a href=#-create-pipeline-create-staticlogic-pipeline-operations>-create-pipeline: Create StaticLogic pipeline operations</a></li><li><a href=#-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files>-export-split-verilog: Emit the IR to a (System)Verilog directory of files</a></li><li><a href=#-export-verilog-emit-the-ir-to-a-systemverilog-file>-export-verilog: Emit the IR to a (System)Verilog file</a></li><li><a href=#-handshake-insert-buffer-insert-buffers-to-break-graph-cycles>-handshake-insert-buffer: Insert buffers to break graph cycles</a></li><li><a href=#-handshake-remove-block-structure-remove-block-structure-in-handshake-ir>-handshake-remove-block-structure: Remove block structure in Handshake IR</a></li><li><a href=#-lower-calyx-to-hw-lower-calyx-to-hw>-lower-calyx-to-hw: Lower Calyx to HW</a></li><li><a href=#-lower-handshake-to-firrtl-lower-handshake-to-firrtl>-lower-handshake-to-firrtl: Lower Handshake to FIRRTL</a></li><li><a href=#-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir>-lower-std-to-handshake: Lower Standard MLIR into Handshake IR</a></li></ul></li><li><a href=#esi-dialect-passes>ESI Dialect Passes</a><ul><li><a href=#-lower-esi-ports-lower-esi-input-andor-output-ports>-lower-esi-ports: Lower ESI input and/or output ports.</a></li><li><a href=#-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere>-lower-esi-to-hw: Lower ESI to HW where possible and SV elsewhere.</a></li><li><a href=#-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops>-lower-esi-to-physical: Lower ESI abstract Ops to ESI physical ops.</a></li></ul></li><li><a href=#firrtl-dialect-passes>FIRRTL Dialect Passes</a><ul><li><a href=#-firrtl-blackbox-memory-replace-all-firrtl-memories-with-an-external-module-black-box>-firrtl-blackbox-memory: Replace all FIRRTL memories with an external module black box.</a></li><li><a href=#-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir>-firrtl-blackbox-reader: Load source files for black boxes into the IR</a></li><li><a href=#-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors>-firrtl-check-comb-cycles: Check combinational cycles and emit errors</a></li><li><a href=#-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules>-firrtl-emit-metadata: Emit metadata of the FIRRTL modules</a></li><li><a href=#-firrtl-emit-omir-emit-omir-annotations>-firrtl-emit-omir: Emit OMIR annotations</a></li><li><a href=#-firrtl-expand-whens-remove-all-when-conditional-blocks>-firrtl-expand-whens: Remove all when conditional blocks.</a></li><li><a href=#-firrtl-grand-central-remove-grand-central-annotations>-firrtl-grand-central: Remove Grand Central Annotations</a></li><li><a href=#-firrtl-grand-central-signal-mappings-generate-signal-mappings-that-forceprobe-remote-signals>-firrtl-grand-central-signal-mappings: Generate signal mappings that force/probe remote signals</a></li><li><a href=#-firrtl-grand-central-taps-generate-code-for-grand-central-data-and-memory-taps>-firrtl-grand-central-taps: Generate code for grand central data and memory taps</a></li><li><a href=#-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination>-firrtl-imconstprop: Intermodule constant propagation and dead code elimination</a></li><li><a href=#-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets>-firrtl-infer-resets: Infer reset synchronicity and add implicit resets</a></li><li><a href=#-firrtl-infer-widths-infer-the-width-of-types>-firrtl-infer-widths: Infer the width of types</a></li><li><a href=#-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination>-firrtl-inliner: Performs inlining, flattening, and dead module elimination</a></li><li><a href=#-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities>-firrtl-lower-annotations: Lower FIRRTL annotations to usable entities</a></li><li><a href=#-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem>-firrtl-lower-chirrtl: Infer the memory ports of SeqMem and CombMem</a></li><li><a href=#-firrtl-lower-types-lower-firrtl-types-to-ground-types>-firrtl-lower-types: Lower FIRRTL types to ground types</a></li><li><a href=#-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hiearchy>-firrtl-prefix-modules: Prefixes names of modules and mems in a hiearchy</a></li><li><a href=#-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy>-firrtl-print-instance-graph: Print a DOT graph of the module hierarchy.</a></li></ul></li><li><a href=#llhd-dialect-passes>LLHD Dialect Passes</a><ul><li><a href=#-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg>-llhd-early-code-motion: Move side-effect-free instructions and llhd.prb up in the CFG</a></li><li><a href=#-llhd-function-elimination-deletes-all-functions>-llhd-function-elimination: Deletes all functions.</a></li><li><a href=#-llhd-memory-to-block-argument-promote-memory-to-block-arguments>-llhd-memory-to-block-argument: Promote memory to block arguments.</a></li><li><a href=#-llhd-process-lowering-lowers-llhd-processes-to-entities>-llhd-process-lowering: Lowers LLHD Processes to Entities.</a></li></ul></li><li><a href=#msft-dialect-passes>MSFT Dialect Passes</a><ul><li><a href=#-lower-msft-to-hw-lower-msft-ops-to-hw-ops>-lower-msft-to-hw: Lower MSFT ops to hw ops</a></li></ul></li><li><a href=#seq-dialect-passes>Seq Dialect Passes</a><ul><li><a href=#-lower-seq-to-sv-lower-sequential-ops-to-sv>-lower-seq-to-sv: Lower sequential ops to SV.</a></li></ul></li><li><a href=#sv-dialect-passes>SV Dialect Passes</a><ul><li><a href=#-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies>-hw-cleanup: Cleanup transformations for operations in hw.module bodies</a></li><li><a href=#-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information>-hw-export-module-hierarchy: Export module and instance hierarchy information</a></li><li><a href=#-hw-generator-callout-lower-generator-schema-to-external-module>-hw-generator-callout: Lower Generator Schema to external module</a></li><li><a href=#-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions>-hw-legalize-modules: Eliminate features marked unsupported in LoweringOptions</a></li><li><a href=#-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model>-hw-memory-sim: Implement FIRRTMMem memories nodes with simulation model</a></li><li><a href=#-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules>-hw-stub-external-modules: transform external hw modules to empty hw modules</a></li><li><a href=#-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output>-prettify-verilog: Transformations to improve quality of ExportVerilog output</a></li><li><a href=#-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind>-sv-extract-test-code: Extract simulation only constructs to modules and bind</a></li></ul></li></ul></nav><h2 id=conversion-passes>Conversion Passes&nbsp;<a class=headline-hash href=#conversion-passes>Â¶</a></h2><h3 id=-convert-affine-to-staticlogic-convert-affine-dialect-to-staticlogic-pipelines><code>-convert-affine-to-staticlogic</code>: Convert Affine dialect to StaticLogic pipelines&nbsp;<a class=headline-hash href=#-convert-affine-to-staticlogic-convert-affine-dialect-to-staticlogic-pipelines>Â¶</a></h3><p>This pass analyzes Affine loops and control flow, creates a Scheduling
problem using the Calyx operator library, solves the problem, and lowers
the loops to a StaticLogic pipeline.</p><h3 id=-convert-hw-to-llhd-convert-hw-to-llhd><code>-convert-hw-to-llhd</code>: Convert HW to LLHD&nbsp;<a class=headline-hash href=#-convert-hw-to-llhd-convert-hw-to-llhd>Â¶</a></h3><p>This pass translates a HW design into an equivalent structural LLHD
description.</p><h3 id=-convert-llhd-to-llvm-convert-llhd-to-llvm><code>-convert-llhd-to-llvm</code>: Convert LLHD to LLVM&nbsp;<a class=headline-hash href=#-convert-llhd-to-llvm-convert-llhd-to-llvm>Â¶</a></h3><p>This pass translates LLHD to LLVM.### <code>-convert-moore-to-core</code>: Convert Moore to Core
This pass translates Moore to the core dialects (Comb/HW/LLHD).</p><h3 id=-create-pipeline-create-staticlogic-pipeline-operations><code>-create-pipeline</code>: Create StaticLogic pipeline operations&nbsp;<a class=headline-hash href=#-create-pipeline-create-staticlogic-pipeline-operations>Â¶</a></h3><h3 id=-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files><code>-export-split-verilog</code>: Emit the IR to a (System)Verilog directory of files&nbsp;<a class=headline-hash href=#-export-split-verilog-emit-the-ir-to-a-systemverilog-directory-of-files>Â¶</a></h3><p>This pass generates (System)Verilog for the current design, mutating it
where necessary to be valid Verilog.</p><h4 id=options>Options&nbsp;<a class=headline-hash href=#options>Â¶</a></h4><pre><code>-dir-name : Directory to emit into
</code></pre><h3 id=-export-verilog-emit-the-ir-to-a-systemverilog-file><code>-export-verilog</code>: Emit the IR to a (System)Verilog file&nbsp;<a class=headline-hash href=#-export-verilog-emit-the-ir-to-a-systemverilog-file>Â¶</a></h3><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-handshake-insert-buffer-insert-buffers-to-break-graph-cycles><code>-handshake-insert-buffer</code>: Insert buffers to break graph cycles&nbsp;<a class=headline-hash href=#-handshake-insert-buffer-insert-buffers-to-break-graph-cycles>Â¶</a></h3><h4 id=options-1>Options&nbsp;<a class=headline-hash href=#options-1>Â¶</a></h4><pre><code>-strategies  : List of strategies to apply. Possible values are: cycles, all (default)
-buffer-size : Number of slots in each buffer
</code></pre><h3 id=-handshake-remove-block-structure-remove-block-structure-in-handshake-ir><code>-handshake-remove-block-structure</code>: Remove block structure in Handshake IR&nbsp;<a class=headline-hash href=#-handshake-remove-block-structure-remove-block-structure-in-handshake-ir>Â¶</a></h3><h3 id=-lower-calyx-to-hw-lower-calyx-to-hw><code>-lower-calyx-to-hw</code>: Lower Calyx to HW&nbsp;<a class=headline-hash href=#-lower-calyx-to-hw-lower-calyx-to-hw>Â¶</a></h3><p>This pass lowers Calyx to HW.### <code>-lower-firrtl-to-hw</code>: Lower FIRRTL to HW
Lower a module of FIRRTL dialect to the HW dialect family.</p><h4 id=options-2>Options&nbsp;<a class=headline-hash href=#options-2>Â¶</a></h4><pre><code>-warn-on-unprocessed-annotations       : Emit warnings on unprocessed annotations during lower-to-hw pass
-error-on-non-const-async-reset-values : Emit errors instead of warnings on non-constant async reset values
</code></pre><h3 id=-lower-handshake-to-firrtl-lower-handshake-to-firrtl><code>-lower-handshake-to-firrtl</code>: Lower Handshake to FIRRTL&nbsp;<a class=headline-hash href=#-lower-handshake-to-firrtl-lower-handshake-to-firrtl>Â¶</a></h3><p>Lower Handshake to FIRRTL.### <code>-lower-scf-to-calyx</code>: Lower SCF/Standard to Calyx
This pass lowers SCF / standard to Calyx.</p><h4 id=options-3>Options&nbsp;<a class=headline-hash href=#options-3>Â¶</a></h4><pre><code>-top-level-function : Identifier of top-level function to be the entry-point component of the Calyx program.
</code></pre><h3 id=-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir><code>-lower-std-to-handshake</code>: Lower Standard MLIR into Handshake IR&nbsp;<a class=headline-hash href=#-lower-std-to-handshake-lower-standard-mlir-into-handshake-ir>Â¶</a></h3><h2 id=esi-dialect-passes>ESI Dialect Passes&nbsp;<a class=headline-hash href=#esi-dialect-passes>Â¶</a></h2><h3 id=-lower-esi-ports-lower-esi-input-andor-output-ports><code>-lower-esi-ports</code>: Lower ESI input and/or output ports.&nbsp;<a class=headline-hash href=#-lower-esi-ports-lower-esi-input-andor-output-ports>Â¶</a></h3><h3 id=-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere><code>-lower-esi-to-hw</code>: Lower ESI to HW where possible and SV elsewhere.&nbsp;<a class=headline-hash href=#-lower-esi-to-hw-lower-esi-to-hw-where-possible-and-sv-elsewhere>Â¶</a></h3><h3 id=-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops><code>-lower-esi-to-physical</code>: Lower ESI abstract Ops to ESI physical ops.&nbsp;<a class=headline-hash href=#-lower-esi-to-physical-lower-esi-abstract-ops-to-esi-physical-ops>Â¶</a></h3><h2 id=firrtl-dialect-passes>FIRRTL Dialect Passes&nbsp;<a class=headline-hash href=#firrtl-dialect-passes>Â¶</a></h2><h3 id=-firrtl-blackbox-memory-replace-all-firrtl-memories-with-an-external-module-black-box><code>-firrtl-blackbox-memory</code>: Replace all FIRRTL memories with an external module black box.&nbsp;<a class=headline-hash href=#-firrtl-blackbox-memory-replace-all-firrtl-memories-with-an-external-module-black-box>Â¶</a></h3><p>This pass replaces all sequential memory operations with an external module
black box. For each memory operation, it creates a FModuleOp which
replicates the return types of the memory operation, and replaces the
MemoryOp with an instance of the module. Inside the new module, an
instance of an FExtModule black box is created. The black box module must
use the same parameter naming conventions used by the ReplaceSeqMemories
pass in the Scala FIRRTL compiler.</p><h4 id=options-4>Options&nbsp;<a class=headline-hash href=#options-4>Â¶</a></h4><pre><code>-emit-wrapper : Create a wrapper module around the black box external module.
</code></pre><h3 id=-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir><code>-firrtl-blackbox-reader</code>: Load source files for black boxes into the IR&nbsp;<a class=headline-hash href=#-firrtl-blackbox-reader-load-source-files-for-black-boxes-into-the-ir>Â¶</a></h3><p>This pass handles reads the Verilog source files for black boxes and adds
them as <code>sv.verbatim.file</code> operations into the IR. Later passes can then
write these files back to disk to ensure that they can be accessed by other
tools down the line in a well-known location. Supports inline, resource, and
path annotations for black box source files.</p><p>The supported <code>firrtl.circuit</code> annotations are:</p><ul><li><code>{class = "firrtl.transforms.BlackBoxTargetDirAnno", targetDir = "..."}</code>
Overrides the target directory into which black box source files are
emitted.</li><li><code>{class = "firrtl.transforms.BlackBoxResourceFileNameAnno", resourceFileName = "xyz.f"}</code>
Specifies the output file name for the list of black box source files that
is generated as a collateral of the pass.</li></ul><p>The supported <code>firrtl.extmodule</code> annotations are:</p><ul><li><pre><code>{
  class = &quot;firrtl.transforms.BlackBoxInlineAnno&quot;,
  name = &quot;myfile.v&quot;,
  text = &quot;...&quot;
}
</code></pre>Specifies the black box source code (<code>text</code>) inline. Generates a file with
the given <code>name</code> in the target directory.</li><li><pre><code>{
  class = &quot;firrtl.transforms.BlackBoxPathAnno&quot;,
  path = &quot;myfile.v&quot;
}
</code></pre>Specifies the file <code>path</code> as source code for the module. Copies the file
to the target directory.</li><li><pre><code>{
  class = &quot;firrtl.transforms.BlackBoxResourceAnno&quot;,
  resourceId = &quot;myfile.v&quot;
}
</code></pre>Specifies the file <code>path</code> as source code for the module. In contrast to
the <code>BlackBoxPathAnno</code>, the file is searched for in the black box resource
search path. This is a remnant of the Scala origins of FIRRTL. Copies the
file to the target directory.</li></ul><h4 id=options-5>Options&nbsp;<a class=headline-hash href=#options-5>Â¶</a></h4><pre><code>-input-prefix    : Prefix for input paths in black box annotations. This should be the directory where the input file was located, to allow for annotations relative to the input file.
-resource-prefix : Search path for black box sources specified via the `BlackBoxResourceAnno` annotation.
</code></pre><h3 id=-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors><code>-firrtl-check-comb-cycles</code>: Check combinational cycles and emit errors&nbsp;<a class=headline-hash href=#-firrtl-check-comb-cycles-check-combinational-cycles-and-emit-errors>Â¶</a></h3><p>This pass checks combinational cycles in the IR and emit errors.</p><h3 id=-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules><code>-firrtl-emit-metadata</code>: Emit metadata of the FIRRTL modules&nbsp;<a class=headline-hash href=#-firrtl-emit-metadata-emit-metadata-of-the-firrtl-modules>Â¶</a></h3><p>This pass handles the emission of several different kinds of metadata.</p><h4 id=options-6>Options&nbsp;<a class=headline-hash href=#options-6>Â¶</a></h4><pre><code>-repl-seq-mem         : Lower the seq mem for macro replacement and emit relevant metadata
-repl-seq-mem-circuit : Circuit root for seq mem metadata
-repl-seq-mem-file    : File to which emit seq meme metadata
</code></pre><h3 id=-firrtl-emit-omir-emit-omir-annotations><code>-firrtl-emit-omir</code>: Emit OMIR annotations&nbsp;<a class=headline-hash href=#-firrtl-emit-omir-emit-omir-annotations>Â¶</a></h3><p>This pass gathers the <code>OMIRAnnotation</code>s in the design, updates the contained
targets with the trackers that were scattered throughout the design upon
reading the OMIR, and serializes the resulting data into a JSON file.</p><h4 id=options-7>Options&nbsp;<a class=headline-hash href=#options-7>Â¶</a></h4><pre><code>-file : Output file for the JSON-serialized OMIR data
</code></pre><h3 id=-firrtl-expand-whens-remove-all-when-conditional-blocks><code>-firrtl-expand-whens</code>: Remove all when conditional blocks.&nbsp;<a class=headline-hash href=#-firrtl-expand-whens-remove-all-when-conditional-blocks>Â¶</a></h3><p>This pass will:</p><ol><li>Resolve last connect semantics.</li><li>Remove all when operations.</li></ol><p>When a wire has multiple connections, only the final connection is used,
all previous connections are overwritten. When there is a conditional
connect, the previous connect is only overwritten when the condition
holds:</p><pre><code class=language-firrtl data-lang=firrtl>w &lt;= a
when c :
  w &lt;= b

; Equivalent to:
w &lt;= mux(c, b, a)
</code></pre><p>This pass requires that all connects are expanded.</p><h3 id=-firrtl-grand-central-remove-grand-central-annotations><code>-firrtl-grand-central</code>: Remove Grand Central Annotations&nbsp;<a class=headline-hash href=#-firrtl-grand-central-remove-grand-central-annotations>Â¶</a></h3><p>Processes annotations associated with SiFive&rsquo;s Grand Central utility.</p><h3 id=-firrtl-grand-central-signal-mappings-generate-signal-mappings-that-forceprobe-remote-signals><code>-firrtl-grand-central-signal-mappings</code>: Generate signal mappings that force/probe remote signals&nbsp;<a class=headline-hash href=#-firrtl-grand-central-signal-mappings-generate-signal-mappings-that-forceprobe-remote-signals>Â¶</a></h3><h3 id=-firrtl-grand-central-taps-generate-code-for-grand-central-data-and-memory-taps><code>-firrtl-grand-central-taps</code>: Generate code for grand central data and memory taps&nbsp;<a class=headline-hash href=#-firrtl-grand-central-taps-generate-code-for-grand-central-data-and-memory-taps>Â¶</a></h3><h3 id=-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination><code>-firrtl-imconstprop</code>: Intermodule constant propagation and dead code elimination&nbsp;<a class=headline-hash href=#-firrtl-imconstprop-intermodule-constant-propagation-and-dead-code-elimination>Â¶</a></h3><p>Use optimistic constant propagation to delete ports and unreachable IR.</p><h4 id=statistics>Statistics&nbsp;<a class=headline-hash href=#statistics>Â¶</a></h4><pre><code>num-folded-op : Number of operations folded
num-erased-op : Number of operations erased
</code></pre><h3 id=-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets><code>-firrtl-infer-resets</code>: Infer reset synchronicity and add implicit resets&nbsp;<a class=headline-hash href=#-firrtl-infer-resets-infer-reset-synchronicity-and-add-implicit-resets>Â¶</a></h3><p>This pass infers whether resets are synchronous or asynchronous, and extends
reset-less registers with an asynchronous reset based on the following
annotations:</p><ul><li><code>sifive.enterprise.firrtl.FullAsyncResetAnnotation</code></li><li><code>sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation</code></li></ul><h3 id=-firrtl-infer-widths-infer-the-width-of-types><code>-firrtl-infer-widths</code>: Infer the width of types&nbsp;<a class=headline-hash href=#-firrtl-infer-widths-infer-the-width-of-types>Â¶</a></h3><p>This pass infers the widths of all types throughout a FIRRTL module, and
emits diagnostics for types that could not be inferred.</p><h3 id=-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination><code>-firrtl-inliner</code>: Performs inlining, flattening, and dead module elimination&nbsp;<a class=headline-hash href=#-firrtl-inliner-performs-inlining-flattening-and-dead-module-elimination>Â¶</a></h3><p>This inliner pass will inline any instance of module marked as inline, and
recursively inline all instances inside of a module marked with flatten.
This pass performs renaming of every entity with a name that is inlined by
prefixing it with the instance name. This pass also will remove any module
which is not reachable from the top level module.</p><p>The inline and flatten annotation attributes are attached to module
definitions, and they are:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.passes.InlineAnnotation&#34;</span><span class=p>}</span>
  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.transforms.FlattenAnnotation&#34;</span><span class=p>}</span>
</code></pre></div><h3 id=-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities><code>-firrtl-lower-annotations</code>: Lower FIRRTL annotations to usable entities&nbsp;<a class=headline-hash href=#-firrtl-lower-annotations-lower-firrtl-annotations-to-usable-entities>Â¶</a></h3><p>Lower FIRRTL annotations to usable forms. FIRRTL annotations are a big bag
of semi-structured, irregular json. This pass normalizes all supported
annotations and annotation paths.</p><h4 id=options-8>Options&nbsp;<a class=headline-hash href=#options-8>Â¶</a></h4><pre><code>-disable-annotation-classless : Ignore classless annotations.
-disable-annotation-unknown   : Ignore unknown annotations.
</code></pre><h3 id=-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem><code>-firrtl-lower-chirrtl</code>: Infer the memory ports of SeqMem and CombMem&nbsp;<a class=headline-hash href=#-firrtl-lower-chirrtl-infer-the-memory-ports-of-seqmem-and-combmem>Â¶</a></h3><p>This pass finds the CHIRRTL behavioral memories and their ports, and
transforms them into standard FIRRTL memory operations. For each
<code>seqmem</code> or <code>combmem</code>, a new memory is created. For every <code>memoryport</code>
operation using a CHIRRTL memory, a memory port is defined on the
new standard memory.</p><p>The direction or kind of the port is inferred from how each of the memory
ports is used in the IR. If a memory port is only written to, it becomes
a <code>Write</code> port. If a memory port is only read from, it become a <code>Read</code>
port. If it is used both ways, it becomes a <code>ReadWrite</code> port.</p><p><code>Write</code>, <code>ReadWrite</code> and combinational <code>Read</code> ports are disabled by
default, but then enabled when the CHIRRTL memory port is declared.
Sequential <code>Read</code> ports have more complicated enable inference:</p><ol><li>If a wire or register is used as the index of the memory port, then
the memory is enabled whenever a non-invalid value is driven to the
address.</li><li>If a node is used as the index of the memory port, then the memory is
enabled at the declaration of the node.</li><li>In all other cases, the memory is never enabled.</li></ol><p>In the first two cases, they can easily produce a situation where we try
to enable the memory before it is even declared. This produces a
compilation error.</p><h3 id=-firrtl-lower-types-lower-firrtl-types-to-ground-types><code>-firrtl-lower-types</code>: Lower FIRRTL types to ground types&nbsp;<a class=headline-hash href=#-firrtl-lower-types-lower-firrtl-types-to-ground-types>Â¶</a></h3><p>Lower aggregate FIRRTL types to ground types. Memories, ports, wires, etc
are split appart by elements of aggregate types. The only aggregate types
which exist after this pass are memory ports, though memory data types are
split.</p><p>Connect and partial connect expansion and canonicalization happen in this
pass.</p><h4 id=options-9>Options&nbsp;<a class=headline-hash href=#options-9>Â¶</a></h4><pre><code>-flatten-mem : Concat all elements of the aggregate data into a single element.
</code></pre><h3 id=-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hiearchy><code>-firrtl-prefix-modules</code>: Prefixes names of modules and mems in a hiearchy&nbsp;<a class=headline-hash href=#-firrtl-prefix-modules-prefixes-names-of-modules-and-mems-in-a-hiearchy>Â¶</a></h3><p>This pass looks for modules annotated with the
<code>NestedPrefixModulesAnnotation</code> and prefixes the names of all modules
instantiated underneath it. If <code>inclusive</code> is true, it includes the target
module in the renaming. If <code>inclusive</code> is false, it will only rename
modules instantiated underneath the target module. If a module is required
to have two different prefixes, it will be cloned.</p><p>The supported annotation is:</p><pre><code>  {
    class = &quot;sifive.enterprise.firrtl.NestedPrefixModulesAnnotation&quot;,
    prefix = &quot;MyPrefix_&quot;,
    inclusive = true
  }
</code></pre><h3 id=-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy><code>-firrtl-print-instance-graph</code>: Print a DOT graph of the module hierarchy.&nbsp;<a class=headline-hash href=#-firrtl-print-instance-graph-print-a-dot-graph-of-the-module-hierarchy>Â¶</a></h3><h2 id=llhd-dialect-passes>LLHD Dialect Passes&nbsp;<a class=headline-hash href=#llhd-dialect-passes>Â¶</a></h2><h3 id=-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg><code>-llhd-early-code-motion</code>: Move side-effect-free instructions and llhd.prb up in the CFG&nbsp;<a class=headline-hash href=#-llhd-early-code-motion-move-side-effect-free-instructions-and-llhdprb-up-in-the-cfg>Â¶</a></h3><p>Moves side-effect-free instructions as far up in the CFG as possible. That
means to the earliest block where all operands are defined. Special care has
to be given to the <code>llhd.prb</code> instruction (which is the only side-effect
instruction moved by this pass) as it must stay in the same temporal region,
because otherwise it might sample an older or newer state of the signal.
This pass is designed as a preparatory pass for the Temporal Code Motion
pass to be able to move the <code>llhd.drv</code> operations in a single TR exiting
block without having to move operations defining the operands used by the
<code>llhd.drv</code>. It also enables total control flow elimination as the <code>llhd.prb</code>
instructions would not be moved by other canonicalization passes.</p><h3 id=-llhd-function-elimination-deletes-all-functions><code>-llhd-function-elimination</code>: Deletes all functions.&nbsp;<a class=headline-hash href=#-llhd-function-elimination-deletes-all-functions>Â¶</a></h3><p>Deletes all functions in the module. In case there is still a function
call in an entity or process, it fails.
This pass is intended as a post-inlining pass to check if all functions
could be successfully inlined and remove the inlined functions. This
is necessary because Structural LLHD does not allow functions. Fails in
the case that there is still a function call left in a <code>llhd.proc</code> or
<code>llhd.entity</code>.</p><h3 id=-llhd-memory-to-block-argument-promote-memory-to-block-arguments><code>-llhd-memory-to-block-argument</code>: Promote memory to block arguments.&nbsp;<a class=headline-hash href=#-llhd-memory-to-block-argument-promote-memory-to-block-arguments>Â¶</a></h3><p>Promotes memory locations allocated with <code>llhd.var</code> to block arguments. This
enables other optimizations and is required to be able to lower behavioral
LLHD to structural LLHD. This is because there are no memory model and
control flow in structural LLHD. After executing this pass, the
&ldquo;-llhd-block-argument-to-mux&rdquo; pass can be used to convert the block
arguments to multiplexers to enable more control-flow elimination.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
  <span class=nv>%ptr</span> <span class=p>=</span> llhd<span class=p>.</span>var <span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span>
  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
  llhd<span class=p>.</span>store <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%c6</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  br <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb2</span><span class=p>:</span>
  <span class=nv>%ld</span> <span class=p>=</span> llhd<span class=p>.</span>load <span class=nv>%ptr</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%ld</span> <span class=p>:</span> <span class=k>i32</span>
  llhd<span class=p>.</span>halt
<span class=p>}</span>
</code></pre></div><p>is transformed to</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
  br <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c6</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span>
  llhd<span class=p>.</span>halt
<span class=p>}</span>
</code></pre></div><h3 id=-llhd-process-lowering-lowers-llhd-processes-to-entities><code>-llhd-process-lowering</code>: Lowers LLHD Processes to Entities.&nbsp;<a class=headline-hash href=#-llhd-process-lowering-lowers-llhd-processes-to-entities>Â¶</a></h3><p>TODO</p><h2 id=msft-dialect-passes>MSFT Dialect Passes&nbsp;<a class=headline-hash href=#msft-dialect-passes>Â¶</a></h2><h3 id=-lower-msft-to-hw-lower-msft-ops-to-hw-ops><code>-lower-msft-to-hw</code>: Lower MSFT ops to hw ops&nbsp;<a class=headline-hash href=#-lower-msft-to-hw-lower-msft-ops-to-hw-ops>Â¶</a></h3><h4 id=options-10>Options&nbsp;<a class=headline-hash href=#options-10>Â¶</a></h4><pre><code>-tops         : List of top modules to export Tcl for
-verilog-file : File to output Verilog into
-tcl-file     : File to output Tcl into
</code></pre><h2 id=seq-dialect-passes>Seq Dialect Passes&nbsp;<a class=headline-hash href=#seq-dialect-passes>Â¶</a></h2><h3 id=-lower-seq-to-sv-lower-sequential-ops-to-sv><code>-lower-seq-to-sv</code>: Lower sequential ops to SV.&nbsp;<a class=headline-hash href=#-lower-seq-to-sv-lower-sequential-ops-to-sv>Â¶</a></h3><h2 id=sv-dialect-passes>SV Dialect Passes&nbsp;<a class=headline-hash href=#sv-dialect-passes>Â¶</a></h2><h3 id=-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies><code>-hw-cleanup</code>: Cleanup transformations for operations in hw.module bodies&nbsp;<a class=headline-hash href=#-hw-cleanup-cleanup-transformations-for-operations-in-hwmodule-bodies>Â¶</a></h3><p>This pass merges sv.alwaysff operations with the same condition, sv.ifdef
nodes with the same condition, and perform other cleanups for the IR.
This is a good thing to run early in the HW/SV pass pipeline to expose
opportunities for other simpler passes (like canonicalize).</p><h3 id=-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information><code>-hw-export-module-hierarchy</code>: Export module and instance hierarchy information&nbsp;<a class=headline-hash href=#-hw-export-module-hierarchy-export-module-and-instance-hierarchy-information>Â¶</a></h3><p>This pass exports the module and instance hierarchy tree for each module
with the firrtl.moduleHierarchyFile attribute. These are lowered to
sv.verbatim ops with the output_file attribute.</p><h4 id=options-11>Options&nbsp;<a class=headline-hash href=#options-11>Â¶</a></h4><pre><code>-dir-name : Directory to emit into
</code></pre><h3 id=-hw-generator-callout-lower-generator-schema-to-external-module><code>-hw-generator-callout</code>: Lower Generator Schema to external module&nbsp;<a class=headline-hash href=#-hw-generator-callout-lower-generator-schema-to-external-module>Â¶</a></h3><p>This pass calls an external program for all the hw.module.generated nodes,
following the description in the hw.generator.schema node.</p><h4 id=options-12>Options&nbsp;<a class=headline-hash href=#options-12>Â¶</a></h4><pre><code>-schema-name                    : Name of the schema to process
-generator-executable           : Generator program executable with optional full path
-generator-executable-arguments : Generator program arguments separated by ;
</code></pre><h3 id=-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions><code>-hw-legalize-modules</code>: Eliminate features marked unsupported in LoweringOptions&nbsp;<a class=headline-hash href=#-hw-legalize-modules-eliminate-features-marked-unsupported-in-loweringoptions>Â¶</a></h3><p>This pass lowers away features in the SV/Comb/HW dialects that are
unsupported by some tools, e.g. multidimensional arrays. This pass is
run relatively late in the pipeline in preparation for emission. Any
passes run after this must be aware they cannot introduce new invalid
constructs.</p><h3 id=-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model><code>-hw-memory-sim</code>: Implement FIRRTMMem memories nodes with simulation model&nbsp;<a class=headline-hash href=#-hw-memory-sim-implement-firrtmmem-memories-nodes-with-simulation-model>Â¶</a></h3><p>This pass replaces generated module nodes of type FIRRTLMem with a model
suitable for simulation.</p><h4 id=options-13>Options&nbsp;<a class=headline-hash href=#options-13>Â¶</a></h4><pre><code>-repl-seq-mem : Prepare seq mems for macro replacement
</code></pre><h3 id=-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules><code>-hw-stub-external-modules</code>: transform external hw modules to empty hw modules&nbsp;<a class=headline-hash href=#-hw-stub-external-modules-transform-external-hw-modules-to-empty-hw-modules>Â¶</a></h3><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output><code>-prettify-verilog</code>: Transformations to improve quality of ExportVerilog output&nbsp;<a class=headline-hash href=#-prettify-verilog-transformations-to-improve-quality-of-exportverilog-output>Â¶</a></h3><p>This pass contains elective transformations that improve the quality of
SystemVerilog generated by the ExportVerilog library. This pass is not
compulsory: things that are required for ExportVerilog to be correct
should be included as part of the ExportVerilog pass itself to make sure
it is self contained.</p><h3 id=-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind><code>-sv-extract-test-code</code>: Extract simulation only constructs to modules and bind&nbsp;<a class=headline-hash href=#-sv-extract-test-code-extract-simulation-only-constructs-to-modules-and-bind>Â¶</a></h3><p>This pass extracts cover, assume, assert operations to a module, along with
any ops feeding them only, to modules which are instantiated with a bind
statement.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/RationaleHW/ title="HW Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - HW Dialect Rationale</a>
<a class="nav nav-next" href=/docs/PyCDE/ title=PyCDE>Next - PyCDE <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li class=active><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>