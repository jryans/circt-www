<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'firrtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'firrtl' Dialect</h1><p>Types and operations for firrtl dialect
This dialect defines the <code>firrtl</code> dialect, which is used to lower from
Chisel code to Verilog. For more information, see the
<a href=https://github.com/freechipsproject/firrtl>FIRRTL GitHub page</a>
.</p><p><nav id=TableOfContents><ul><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#augmentedbooleantypeattr>AugmentedBooleanTypeAttr</a></li><li><a href=#augmentedbundletypeattr>AugmentedBundleTypeAttr</a></li><li><a href=#augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</a></li><li><a href=#augmenteddoubletypeattr>AugmentedDoubleTypeAttr</a></li><li><a href=#augmentedgroundtypeattr>AugmentedGroundTypeAttr</a></li><li><a href=#augmentedintegertypeattr>AugmentedIntegerTypeAttr</a></li><li><a href=#augmentedliteraltypeattr>AugmentedLiteralTypeAttr</a></li><li><a href=#augmentedstringtypeattr>AugmentedStringTypeAttr</a></li><li><a href=#augmentedvectortypeattr>AugmentedVectorTypeAttr</a></li><li><a href=#invalidvalueattr>InvalidValueAttr</a></li><li><a href=#subannotationattr>SubAnnotationAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#analog-type>analog type</a></li><li><a href=#reset>Reset</a></li><li><a href=#asyncreset>AsyncReset</a></li><li><a href=#bundletype>BundleType</a></li><li><a href=#a-behavioral-memory-port>a behavioral memory port</a></li><li><a href=#a-behavioral-memory>a behavioral memory</a></li><li><a href=#clock>clock</a></li><li><a href=#firrtltype>FIRRTLType</a></li><li><a href=#fvectortype>FVectorType</a></li><li><a href=#sint-or-uint-type>sint or uint type</a></li><li><a href=#uint1-sint1-or-analog1>UInt<1>, SInt<1>, or Analog<1></a></li><li><a href=#a-passive-type-contain-no-flips>a passive type (contain no flips)</a></li><li><a href=#reset-1>Reset</a></li><li><a href=#sint-type>sint type</a></li><li><a href=#uint1-or-uint>UInt<1> or UInt</a></li><li><a href=#uint-type>uint type</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#firrtladd-circtfirrtladdprimop>firrtl.add (::circt::firrtl::AddPrimOp)</a></li><li><a href=#firrtland-circtfirrtlandprimop>firrtl.and (::circt::firrtl::AndPrimOp)</a></li><li><a href=#firrtlandr-circtfirrtlandrprimop>firrtl.andr (::circt::firrtl::AndRPrimOp)</a></li><li><a href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop>firrtl.asAsyncReset (::circt::firrtl::AsAsyncResetPrimOp)</a></li><li><a href=#firrtlasclock-circtfirrtlasclockprimop>firrtl.asClock (::circt::firrtl::AsClockPrimOp)</a></li><li><a href=#firrtlassint-circtfirrtlassintprimop>firrtl.asSInt (::circt::firrtl::AsSIntPrimOp)</a></li><li><a href=#firrtlasuint-circtfirrtlasuintprimop>firrtl.asUInt (::circt::firrtl::AsUIntPrimOp)</a></li><li><a href=#firrtlassert-circtfirrtlassertop>firrtl.assert (::circt::firrtl::AssertOp)</a></li><li><a href=#firrtlassume-circtfirrtlassumeop>firrtl.assume (::circt::firrtl::AssumeOp)</a></li><li><a href=#firrtlattach-circtfirrtlattachop>firrtl.attach (::circt::firrtl::AttachOp)</a></li><li><a href=#firrtlbitcast-circtfirrtlbitcastop>firrtl.bitcast (::circt::firrtl::BitCastOp)</a></li><li><a href=#firrtlbits-circtfirrtlbitsprimop>firrtl.bits (::circt::firrtl::BitsPrimOp)</a></li><li><a href=#firrtlcat-circtfirrtlcatprimop>firrtl.cat (::circt::firrtl::CatPrimOp)</a></li><li><a href=#firrtlcircuit-circtfirrtlcircuitop>firrtl.circuit (::circt::firrtl::CircuitOp)</a></li><li><a href=#firrtlcombmem-circtfirrtlcombmemop>firrtl.combmem (::circt::firrtl::CombMemOp)</a></li><li><a href=#firrtlconnect-circtfirrtlconnectop>firrtl.connect (::circt::firrtl::ConnectOp)</a></li><li><a href=#firrtlconstant-circtfirrtlconstantop>firrtl.constant (::circt::firrtl::ConstantOp)</a></li><li><a href=#firrtlcover-circtfirrtlcoverop>firrtl.cover (::circt::firrtl::CoverOp)</a></li><li><a href=#firrtlcvt-circtfirrtlcvtprimop>firrtl.cvt (::circt::firrtl::CvtPrimOp)</a></li><li><a href=#firrtldshl-circtfirrtldshlprimop>firrtl.dshl (::circt::firrtl::DShlPrimOp)</a></li><li><a href=#firrtldshlw-circtfirrtldshlwprimop>firrtl.dshlw (::circt::firrtl::DShlwPrimOp)</a></li><li><a href=#firrtldshr-circtfirrtldshrprimop>firrtl.dshr (::circt::firrtl::DShrPrimOp)</a></li><li><a href=#firrtldiv-circtfirrtldivprimop>firrtl.div (::circt::firrtl::DivPrimOp)</a></li><li><a href=#firrtleq-circtfirrtleqprimop>firrtl.eq (::circt::firrtl::EQPrimOp)</a></li><li><a href=#firrtlextmodule-circtfirrtlfextmoduleop>firrtl.extmodule (::circt::firrtl::FExtModuleOp)</a></li><li><a href=#firrtlmodule-circtfirrtlfmoduleop>firrtl.module (::circt::firrtl::FModuleOp)</a></li><li><a href=#firrtlforce-circtfirrtlforceop>firrtl.force (::circt::firrtl::ForceOp)</a></li><li><a href=#firrtlgeq-circtfirrtlgeqprimop>firrtl.geq (::circt::firrtl::GEQPrimOp)</a></li><li><a href=#firrtlgt-circtfirrtlgtprimop>firrtl.gt (::circt::firrtl::GTPrimOp)</a></li><li><a href=#firrtlhwstructcast-circtfirrtlhwstructcastop>firrtl.hwStructCast (::circt::firrtl::HWStructCastOp)</a></li><li><a href=#firrtlhead-circtfirrtlheadprimop>firrtl.head (::circt::firrtl::HeadPrimOp)</a></li><li><a href=#firrtlinstance-circtfirrtlinstanceop>firrtl.instance (::circt::firrtl::InstanceOp)</a></li><li><a href=#firrtlinvalidvalue-circtfirrtlinvalidvalueop>firrtl.invalidvalue (::circt::firrtl::InvalidValueOp)</a></li><li><a href=#firrtlleq-circtfirrtlleqprimop>firrtl.leq (::circt::firrtl::LEQPrimOp)</a></li><li><a href=#firrtllt-circtfirrtlltprimop>firrtl.lt (::circt::firrtl::LTPrimOp)</a></li><li><a href=#firrtlmem-circtfirrtlmemop>firrtl.mem (::circt::firrtl::MemOp)</a></li><li><a href=#firrtlmemoryportaccess-circtfirrtlmemoryportaccessop>firrtl.memoryport.access (::circt::firrtl::MemoryPortAccessOp)</a></li><li><a href=#firrtlmemoryport-circtfirrtlmemoryportop>firrtl.memoryport (::circt::firrtl::MemoryPortOp)</a></li><li><a href=#firrtlmul-circtfirrtlmulprimop>firrtl.mul (::circt::firrtl::MulPrimOp)</a></li><li><a href=#firrtlmux-circtfirrtlmuxprimop>firrtl.mux (::circt::firrtl::MuxPrimOp)</a></li><li><a href=#firrtlneq-circtfirrtlneqprimop>firrtl.neq (::circt::firrtl::NEQPrimOp)</a></li><li><a href=#firrtlneg-circtfirrtlnegprimop>firrtl.neg (::circt::firrtl::NegPrimOp)</a></li><li><a href=#firrtlnode-circtfirrtlnodeop>firrtl.node (::circt::firrtl::NodeOp)</a></li><li><a href=#firrtlnla-circtfirrtlnonlocalanchor>firrtl.nla (::circt::firrtl::NonLocalAnchor)</a></li><li><a href=#firrtlnot-circtfirrtlnotprimop>firrtl.not (::circt::firrtl::NotPrimOp)</a></li><li><a href=#firrtlor-circtfirrtlorprimop>firrtl.or (::circt::firrtl::OrPrimOp)</a></li><li><a href=#firrtlorr-circtfirrtlorrprimop>firrtl.orr (::circt::firrtl::OrRPrimOp)</a></li><li><a href=#firrtlpad-circtfirrtlpadprimop>firrtl.pad (::circt::firrtl::PadPrimOp)</a></li><li><a href=#firrtlpartialconnect-circtfirrtlpartialconnectop>firrtl.partialconnect (::circt::firrtl::PartialConnectOp)</a></li><li><a href=#firrtlprintf-circtfirrtlprintfop>firrtl.printf (::circt::firrtl::PrintFOp)</a></li><li><a href=#firrtlreg-circtfirrtlregop>firrtl.reg (::circt::firrtl::RegOp)</a></li><li><a href=#firrtlregreset-circtfirrtlregresetop>firrtl.regreset (::circt::firrtl::RegResetOp)</a></li><li><a href=#firrtlrem-circtfirrtlremprimop>firrtl.rem (::circt::firrtl::RemPrimOp)</a></li><li><a href=#firrtlseqmem-circtfirrtlseqmemop>firrtl.seqmem (::circt::firrtl::SeqMemOp)</a></li><li><a href=#firrtlshl-circtfirrtlshlprimop>firrtl.shl (::circt::firrtl::ShlPrimOp)</a></li><li><a href=#firrtlshr-circtfirrtlshrprimop>firrtl.shr (::circt::firrtl::ShrPrimOp)</a></li><li><a href=#firrtlskip-circtfirrtlskipop>firrtl.skip (::circt::firrtl::SkipOp)</a></li><li><a href=#firrtlspecialconstant-circtfirrtlspecialconstantop>firrtl.specialconstant (::circt::firrtl::SpecialConstantOp)</a></li><li><a href=#firrtlstop-circtfirrtlstopop>firrtl.stop (::circt::firrtl::StopOp)</a></li><li><a href=#firrtlsub-circtfirrtlsubprimop>firrtl.sub (::circt::firrtl::SubPrimOp)</a></li><li><a href=#firrtlsubaccess-circtfirrtlsubaccessop>firrtl.subaccess (::circt::firrtl::SubaccessOp)</a></li><li><a href=#firrtlsubfield-circtfirrtlsubfieldop>firrtl.subfield (::circt::firrtl::SubfieldOp)</a></li><li><a href=#firrtlsubindex-circtfirrtlsubindexop>firrtl.subindex (::circt::firrtl::SubindexOp)</a></li><li><a href=#firrtltail-circtfirrtltailprimop>firrtl.tail (::circt::firrtl::TailPrimOp)</a></li><li><a href=#firrtlverbatimexpr-circtfirrtlverbatimexprop>firrtl.verbatim.expr (::circt::firrtl::VerbatimExprOp)</a></li><li><a href=#firrtlverbatimwire-circtfirrtlverbatimwireop>firrtl.verbatim.wire (::circt::firrtl::VerbatimWireOp)</a></li><li><a href=#firrtlwhen-circtfirrtlwhenop>firrtl.when (::circt::firrtl::WhenOp)</a></li><li><a href=#firrtlwire-circtfirrtlwireop>firrtl.wire (::circt::firrtl::WireOp)</a></li><li><a href=#firrtlxor-circtfirrtlxorprimop>firrtl.xor (::circt::firrtl::XorPrimOp)</a></li><li><a href=#firrtlxorr-circtfirrtlxorrprimop>firrtl.xorr (::circt::firrtl::XorRPrimOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#cmemoryporttype>CMemoryPortType</a></li><li><a href=#cmemorytype>CMemoryType</a></li></ul></li></ul></nav><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=augmentedbooleantypeattr>AugmentedBooleanTypeAttr&nbsp;<a class=headline-hash href=#augmentedbooleantypeattr>¶</a></h3><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedbundletypeattr>AugmentedBundleTypeAttr&nbsp;<a class=headline-hash href=#augmentedbundletypeattr>¶</a></h3><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddeletedtypeattr>AugmentedDeletedTypeAttr&nbsp;<a class=headline-hash href=#augmenteddeletedtypeattr>¶</a></h3><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddoubletypeattr>AugmentedDoubleTypeAttr&nbsp;<a class=headline-hash href=#augmenteddoubletypeattr>¶</a></h3><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedgroundtypeattr>AugmentedGroundTypeAttr&nbsp;<a class=headline-hash href=#augmentedgroundtypeattr>¶</a></h3><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedintegertypeattr>AugmentedIntegerTypeAttr&nbsp;<a class=headline-hash href=#augmentedintegertypeattr>¶</a></h3><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedliteraltypeattr>AugmentedLiteralTypeAttr&nbsp;<a class=headline-hash href=#augmentedliteraltypeattr>¶</a></h3><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedstringtypeattr>AugmentedStringTypeAttr&nbsp;<a class=headline-hash href=#augmentedstringtypeattr>¶</a></h3><h4 id=parameters-7>Parameters:&nbsp;<a class=headline-hash href=#parameters-7>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedvectortypeattr>AugmentedVectorTypeAttr&nbsp;<a class=headline-hash href=#augmentedvectortypeattr>¶</a></h3><h4 id=parameters-8>Parameters:&nbsp;<a class=headline-hash href=#parameters-8>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>underlying</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=invalidvalueattr>InvalidValueAttr&nbsp;<a class=headline-hash href=#invalidvalueattr>¶</a></h3><p>A constant value of firrtl.invalid type</p><p>Represents an firrtl.invalidvalue value, whose type is specified by the
type of the attribute.</p><h4 id=parameters-9>Parameters:&nbsp;<a class=headline-hash href=#parameters-9>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>type</td><td align=center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=subannotationattr>SubAnnotationAttr&nbsp;<a class=headline-hash href=#subannotationattr>¶</a></h3><p>An Annotation that targets part of what it&rsquo;s attached to</p><p>An Annotation that is only applicable to part of what it is attached to.
This uses a field ID to indicate to which field it is applicable.</p><h4 id=parameters-10>Parameters:&nbsp;<a class=headline-hash href=#parameters-10>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>fieldID</td><td align=center><code>int64_t</code></td><td></td></tr><tr><td align=center>annotations</td><td align=center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=analog-type>analog type&nbsp;<a class=headline-hash href=#analog-type>¶</a></h3><h3 id=reset>Reset&nbsp;<a class=headline-hash href=#reset>¶</a></h3><h3 id=asyncreset>AsyncReset&nbsp;<a class=headline-hash href=#asyncreset>¶</a></h3><h3 id=bundletype>BundleType&nbsp;<a class=headline-hash href=#bundletype>¶</a></h3><h3 id=a-behavioral-memory-port>a behavioral memory port&nbsp;<a class=headline-hash href=#a-behavioral-memory-port>¶</a></h3><p>Syntax:</p><pre><code>cmemoryport-type ::= `cmemoryport`
</code></pre><p>The value of a <code>cmemoryport</code> type represents a port which has been
declared on a <code>cmemory</code>. This value is used to set the memory port access
conditions.</p><h3 id=a-behavioral-memory>a behavioral memory&nbsp;<a class=headline-hash href=#a-behavioral-memory>¶</a></h3><p>Syntax:</p><pre><code>cmemory-type ::= `cmemory` `&lt;` element-type, element-count `&gt;`
</code></pre><p>The value of a <code>cmemory</code> type represents a behavioral memory with unknown
ports. This is produced by <code>combmem</code> and <code>seqmem</code> declarations and used by
<code>memoryport</code> declarations to define memories and their ports. A CMemory is
similar to a vector of passive element types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>16</span><span class=p>&gt;</span>
<span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>bundle<span class=p>&lt;</span>a <span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>16</span><span class=p>&gt;</span>
</code></pre></div><h3 id=clock>clock&nbsp;<a class=headline-hash href=#clock>¶</a></h3><h3 id=firrtltype>FIRRTLType&nbsp;<a class=headline-hash href=#firrtltype>¶</a></h3><h3 id=fvectortype>FVectorType&nbsp;<a class=headline-hash href=#fvectortype>¶</a></h3><h3 id=sint-or-uint-type>sint or uint type&nbsp;<a class=headline-hash href=#sint-or-uint-type>¶</a></h3><h3 id=uint1-sint1-or-analog1>UInt&lt;1>, SInt&lt;1>, or Analog&lt;1>&nbsp;<a class=headline-hash href=#uint1-sint1-or-analog1>¶</a></h3><h3 id=a-passive-type-contain-no-flips>a passive type (contain no flips)&nbsp;<a class=headline-hash href=#a-passive-type-contain-no-flips>¶</a></h3><h3 id=reset-1>Reset&nbsp;<a class=headline-hash href=#reset-1>¶</a></h3><h3 id=sint-type>sint type&nbsp;<a class=headline-hash href=#sint-type>¶</a></h3><h3 id=uint1-or-uint>UInt&lt;1> or UInt&nbsp;<a class=headline-hash href=#uint1-or-uint>¶</a></h3><h3 id=uint-type>uint type&nbsp;<a class=headline-hash href=#uint-type>¶</a></h3><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)&nbsp;<a class=headline-hash href=#firrtladd-circtfirrtladdprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)&nbsp;<a class=headline-hash href=#firrtland-circtfirrtlandprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)&nbsp;<a class=headline-hash href=#firrtlandr-circtfirrtlandrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;and&rsquo; operation to merge
bits. <code>andr(x)</code> is equivalent to <code>concat(x, 1b1) == ~0</code>. As such, it
returns 1 for zero-bit-wide operands.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)&nbsp;<a class=headline-hash href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>AsyncReset</td></tr></tbody></table><h3 id=firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)&nbsp;<a class=headline-hash href=#firrtlasclock-circtfirrtlasclockprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)&nbsp;<a class=headline-hash href=#firrtlassint-circtfirrtlassintprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)&nbsp;<a class=headline-hash href=#firrtlasuint-circtfirrtlasuintprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)&nbsp;<a class=headline-hash href=#firrtlassert-circtfirrtlassertop>¶</a></h3><p>Assert Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` type($operands))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>isConcurrent</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>eventControl</code></td><td align=center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)&nbsp;<a class=headline-hash href=#firrtlassume-circtfirrtlassumeop>¶</a></h3><p>Assume Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` type($operands))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>isConcurrent</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>eventControl</code></td><td align=center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)&nbsp;<a class=headline-hash href=#firrtlattach-circtfirrtlattachop>¶</a></h3><p>Analog Attach Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.attach` $operands attr-dict `:` type($operands)
</code></pre><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>analog type</td></tr></tbody></table><h3 id=firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)&nbsp;<a class=headline-hash href=#firrtlbitcast-circtfirrtlbitcastop>¶</a></h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type. This op is lowered to hw::BitCastOp.
</code></pre><p>Syntax:</p><pre><code>operation ::= `firrtl.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)&nbsp;<a class=headline-hash href=#firrtlbits-circtfirrtlbitsprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>bits</code> operation extracts the bits between <code>hi</code> (inclusive) and <code>lo</code>
(inclusive) from <code>input</code>. <code>hi</code> must be greater than or equal to <code>lo</code>. Both
<code>hi</code> and <code>lo</code> must be non-negative and less than the bit width of <code>input</code>.
The result is <code>hi - lo + 1</code> bits wide.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>hi</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>lo</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)&nbsp;<a class=headline-hash href=#firrtlcat-circtfirrtlcatprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.cat` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)&nbsp;<a class=headline-hash href=#firrtlcircuit-circtfirrtlcircuitop>¶</a></h3><p>FIRRTL Circuit</p><p>Syntax:</p><pre><code>operation ::= `firrtl.circuit` $name custom&lt;CircuitOpAttrs&gt;(attr-dict) $body
</code></pre><p>The &ldquo;firrtl.circuit&rdquo; operation represents an overall Verilog circuit,
containing a list of modules.</p><p>Traits: IsolatedFromAbove, NoRegionArguments, NoTerminator, SingleBlock, SymbolTable</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h3 id=firrtlcombmem-circtfirrtlcombmemop><code>firrtl.combmem</code> (::circt::firrtl::CombMemOp)&nbsp;<a class=headline-hash href=#firrtlcombmem-circtfirrtlcombmemop>¶</a></h3><p>Define a new combinational memory</p><p>Syntax:</p><pre><code>operation ::= `firrtl.combmem` custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Define a new behavioral combinational memory. Combinational memories have a
write latency of 1 and a read latency of 0.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a behavioral memory</td></tr></tbody></table><h3 id=firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)&nbsp;<a class=headline-hash href=#firrtlconnect-circtfirrtlconnectop>¶</a></h3><p>Connect two signals</p><p>Syntax:</p><pre><code>operation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` type($dest) `,` type($src)
</code></pre><p>Connect Operation:</p><pre><code>  firrtl.connect %dest, %src : t1, t2
</code></pre><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)&nbsp;<a class=headline-hash href=#firrtlconstant-circtfirrtlconstantop>¶</a></h3><p>Produce a constant value</p><p>The constant operation produces a constant value of SInt or UInt type, it
never produces a zero bit wide result.</p><pre><code>  %result = firrtl.constant 42 : t1
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::IntegerAttr</td><td>arbitrary integer attribute with sign</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)&nbsp;<a class=headline-hash href=#firrtlcover-circtfirrtlcoverop>¶</a></h3><p>Cover Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` type($operands))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>isConcurrent</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>eventControl</code></td><td align=center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)&nbsp;<a class=headline-hash href=#firrtlcvt-circtfirrtlcvtprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)&nbsp;<a class=headline-hash href=#firrtldshl-circtfirrtldshlprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>A dynamic shift left operation. The width of <code>$result</code> is expanded to
<code>width($lhs) + 1 &lt;&lt; width($rhs) - 1</code>.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)&nbsp;<a class=headline-hash href=#firrtldshlw-circtfirrtldshlwprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>A dynamic shift left operation same as &lsquo;dshl&rsquo; but with different width rule.
The width of <code>$result</code> is equal to <code>$lhs</code>.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)&nbsp;<a class=headline-hash href=#firrtldshr-circtfirrtldshrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)&nbsp;<a class=headline-hash href=#firrtldiv-circtfirrtldivprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Divides the first argument (the numerator) by the second argument
(the denominator) truncating the result (rounding towards zero).</p><p><strong>If the denominator is zero, the result is undefined.</strong></p><p>The compiler may optimize this undefined behavior in any way it
wants. Notably <code>div(a, a)</code> will be optimized to <code>1</code>. This may cause
erroneous formal equivalence mismatches between unoptimized and
optimized FIRRTL dialects that are separately converted to Verilog.</p><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)&nbsp;<a class=headline-hash href=#firrtleq-circtfirrtleqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)&nbsp;<a class=headline-hash href=#firrtlextmodule-circtfirrtlfextmoduleop>¶</a></h3><p>FIRRTL extmodule</p><p>The &ldquo;firrtl.extmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove</p><p>Interfaces: FModuleLike, Symbol</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defname</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h3 id=firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)&nbsp;<a class=headline-hash href=#firrtlmodule-circtfirrtlfmoduleop>¶</a></h3><p>FIRRTL Module</p><p>The &ldquo;firrtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove, NoTerminator, SingleBlock</p><p>Interfaces: FModuleLike, Symbol</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h3 id=firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)&nbsp;<a class=headline-hash href=#firrtlforce-circtfirrtlforceop>¶</a></h3><p>Force procedural statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.force` $dest `,` $src attr-dict `:` type($dest) `,` type($src)
</code></pre><p>Maps to the corresponding <code>sv.force</code> operation.
Traits: SameTypeOperands</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlgeq-circtfirrtlgeqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)&nbsp;<a class=headline-hash href=#firrtlgt-circtfirrtlgtprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)&nbsp;<a class=headline-hash href=#firrtlhwstructcast-circtfirrtlhwstructcastop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.hwStructCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)&nbsp;<a class=headline-hash href=#firrtlhead-circtfirrtlheadprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)&nbsp;<a class=headline-hash href=#firrtlinstance-circtfirrtlinstanceop>¶</a></h3><p>Instantiate an instance of a module</p><p>This represents an instance of a module. The results are the modules inputs
and outputs. The inputs have flip type, the outputs do not.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>instance foo <span class=nf>@Foo</span><span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</code></pre></div><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>moduleName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>portDirections</code></td><td align=center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td align=center><code>portNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>portAnnotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>lowerToBind</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)&nbsp;<a class=headline-hash href=#firrtlinvalidvalue-circtfirrtlinvalidvalueop>¶</a></h3><p>InvalidValue primitive</p><p>Syntax:</p><pre><code>operation ::= `firrtl.invalidvalue` attr-dict `:` type($result)
</code></pre><p>The InvalidValue operation returns an invalid value of a specified type:</p><pre><code>  %result = firrtl.invalid : !firrtl.uint&lt;1&gt;
</code></pre><p>This corresponds to the FIRRTL invalidate operation without the implicit
connect semantics.</p><p>Traits: ConstantLike</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlleq-circtfirrtlleqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)&nbsp;<a class=headline-hash href=#firrtllt-circtfirrtlltprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)&nbsp;<a class=headline-hash href=#firrtlmem-circtfirrtlmemop>¶</a></h3><p>Define a new mem</p><p>Syntax:</p><pre><code>operation ::= `firrtl.mem` (`sym` $inner_sym^)?
              $ruw custom&lt;MemOp&gt;(attr-dict) `:` type($results)
</code></pre><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>readLatency</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td align=center><code>writeLatency</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td align=center><code>depth</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td align=center><code>ruw</code></td><td align=center>::RUWAttrAttr</td><td>Read Under Write Enum</td></tr><tr><td align=center><code>portNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>portAnnotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlmemoryportaccess-circtfirrtlmemoryportaccessop><code>firrtl.memoryport.access</code> (::circt::firrtl::MemoryPortAccessOp)&nbsp;<a class=headline-hash href=#firrtlmemoryportaccess-circtfirrtlmemoryportaccessop>¶</a></h3><p>Enables a memory port</p><p>Syntax:</p><pre><code>operation ::= `firrtl.memoryport.access` $port `[` $index `]` `,` $clock attr-dict `:` type(operands)
</code></pre><p>This operation is used to conditionally enable a memory port, and associate
it with a <code>clock</code> and <code>index</code>. The memory port will be actuve on the
positive edge of the clock. The index is the address of the memory
accessed. See the FIRRTL rational for more information about why this
operation exists.</p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>port</code></td><td>a behavioral memory port</td></tr><tr><td align=center><code>index</code></td><td>sint or uint type</td></tr><tr><td align=center><code>clock</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlmemoryport-circtfirrtlmemoryportop><code>firrtl.memoryport</code> (::circt::firrtl::MemoryPortOp)&nbsp;<a class=headline-hash href=#firrtlmemoryport-circtfirrtlmemoryportop>¶</a></h3><p>Defines a memory port on CHIRRTL memory</p><p>Syntax:</p><pre><code>operation ::= `firrtl.memoryport` $direction $memory custom&lt;MemoryPortOp&gt;(attr-dict) `:`
              functional-type(operands, results)
</code></pre><p>This operation defines a new memory port on a <code>seqmem</code> or <code>combmem</code>CHISEL.
<code>data</code> is the data returned from the memory port.</p><p>The memory port requires an access point, which sets the enable condition
of the port, the clock, and the address. This is done by passing the the
<code>port</code> argument to a <code>firrtl.memoryport.access operation</code>.</p><p>Interfaces: InferTypeOpInterface, OpAsmOpInterface</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>direction</code></td><td align=center>::MemDirAttrAttr</td><td>Memory Direction Enum</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory</code></td><td>a behavioral memory</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>data</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>port</code></td><td>a behavioral memory port</td></tr></tbody></table><h3 id=firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)&nbsp;<a class=headline-hash href=#firrtlmul-circtfirrtlmulprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)&nbsp;<a class=headline-hash href=#firrtlmux-circtfirrtlmuxprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sel</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>high</code></td><td>a passive type (contain no flips)</td></tr><tr><td align=center><code>low</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlneq-circtfirrtlneqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)&nbsp;<a class=headline-hash href=#firrtlneg-circtfirrtlnegprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)&nbsp;<a class=headline-hash href=#firrtlnode-circtfirrtlnodeop>¶</a></h3><p>No-op to name a value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.node` (`sym` $inner_sym^)?
              $input custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($input)
</code></pre><p>A node is simply a named intermediate value in a circuit. The node must
be initialized to a value with a passive type and cannot be connected to.
Nodes are often used to split a complicated compound expression into named
subexpressions.</p><pre><code>  %result = firrtl.node %input : t1
</code></pre><p>Traits: SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlnla-circtfirrtlnonlocalanchor><code>firrtl.nla</code> (::circt::firrtl::NonLocalAnchor)&nbsp;<a class=headline-hash href=#firrtlnla-circtfirrtlnonlocalanchor>¶</a></h3><p>Anchor for non-local annotations</p><p>Syntax:</p><pre><code>operation ::= `firrtl.nla` $sym_name $modpath $namepath attr-dict
</code></pre><p>The &ldquo;firrtl.nla&rdquo; operation represents a common point for non-local (path)
annotations to anchor to in the global scope. This lets components of the
path point to a common entity.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove</p><p>Interfaces: Symbol</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>modpath</code></td><td align=center>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr><tr><td align=center><code>namepath</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h3 id=firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)&nbsp;<a class=headline-hash href=#firrtlnot-circtfirrtlnotprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)&nbsp;<a class=headline-hash href=#firrtlor-circtfirrtlorprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)&nbsp;<a class=headline-hash href=#firrtlorr-circtfirrtlorrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;or&rsquo; operation to merge
bits. <code>orr(x)</code> is equivalent to <code>concat(x, 1b0) != 0</code>. As such, it
returns 0 for zero-bit-wide operands.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)&nbsp;<a class=headline-hash href=#firrtlpad-circtfirrtlpadprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Pad the input out to an <code>amount</code> wide integer, sign extending or zero
extending according to <code>input</code>s type. If <code>amount</code> is less than the existing
width of <code>input</code>, then input is unmodified.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlpartialconnect-circtfirrtlpartialconnectop><code>firrtl.partialconnect</code> (::circt::firrtl::PartialConnectOp)&nbsp;<a class=headline-hash href=#firrtlpartialconnect-circtfirrtlpartialconnectop>¶</a></h3><p>Connect two signals</p><p>Syntax:</p><pre><code>operation ::= `firrtl.partialconnect` $dest `,` $src  attr-dict `:` type($dest) `,` type($src)
</code></pre><p>Connect two values with fewer constraints:</p><pre><code>  firrtl.partialconnect %dest, %src : t1, t2
</code></pre><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)&nbsp;<a class=headline-hash href=#firrtlprintf-circtfirrtlprintfop>¶</a></h3><p>Formatted Print Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.printf` $clock `,` $cond `,` $formatString custom&lt;PrintfAttrs&gt;(attr-dict)
              (`(` $operands^ `)` `:` type($operands))?
</code></pre><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>formatString</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>cond</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td align=center><code>operands</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)&nbsp;<a class=headline-hash href=#firrtlreg-circtfirrtlregop>¶</a></h3><p>Define a new register</p><p>Syntax:</p><pre><code>operation ::= `firrtl.reg` (`sym` $inner_sym^)?
              operands custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Declare a new register:</p><pre><code>%name = firrtl.reg %clockVal : t1
</code></pre><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockVal</code></td><td>clock</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)&nbsp;<a class=headline-hash href=#firrtlregreset-circtfirrtlregresetop>¶</a></h3><p>Define a new register with a reset</p><p>Syntax:</p><pre><code>operation ::= `firrtl.regreset` (`sym` $inner_sym^)?
              operands custom&lt;ImplicitSSAName&gt;(attr-dict)
              `:` type($resetSignal) `,` type($resetValue) `,` type($result)
</code></pre><p>Declare a new register:</p><pre><code>  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : t1
</code></pre><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockVal</code></td><td>clock</td></tr><tr><td align=center><code>resetSignal</code></td><td>Reset</td></tr><tr><td align=center><code>resetValue</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)&nbsp;<a class=headline-hash href=#firrtlrem-circtfirrtlremprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlseqmem-circtfirrtlseqmemop><code>firrtl.seqmem</code> (::circt::firrtl::SeqMemOp)&nbsp;<a class=headline-hash href=#firrtlseqmem-circtfirrtlseqmemop>¶</a></h3><p>Define a new sequential memory</p><p>Syntax:</p><pre><code>operation ::= `firrtl.seqmem` $ruw custom&lt;SeqMemOp&gt;(attr-dict) `:` type($result)
</code></pre><p>Define a new behavioral sequential memory. Sequential memories have a
write latency and a read latency of 1.</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ruw</code></td><td align=center>::RUWAttrAttr</td><td>Read Under Write Enum</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a behavioral memory</td></tr></tbody></table><h3 id=firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)&nbsp;<a class=headline-hash href=#firrtlshl-circtfirrtlshlprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shl</code> operation concatenates <code>amount</code> zero bits to the least significant
end of <code>input</code>. <code>amount</code> must be non-negative.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)&nbsp;<a class=headline-hash href=#firrtlshr-circtfirrtlshrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shr</code> operation truncates least significant <code>amount</code> bits from <code>input</code>.
If <code>amount</code> is greater than of equal to <code>width(input)</code>, the value will be
zero for unsigned types and the sign bit for signed types. <code>amount</code> must be
non-negative.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)&nbsp;<a class=headline-hash href=#firrtlskip-circtfirrtlskipop>¶</a></h3><p>Skip statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.skip` attr-dict
</code></pre><p>Skip Statement:</p><pre><code>   %firrtl.skip
</code></pre><p>This is a no-op statement.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h3 id=firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)&nbsp;<a class=headline-hash href=#firrtlspecialconstant-circtfirrtlspecialconstantop>¶</a></h3><p>Produce a constant Reset or Clock value</p><p>The constant operation produces a constant value of Reset, AsyncReset, or
Clock type. The value can only be 0 or 1.</p><pre><code>  %result = firrtl.specialconstant 1 : !firrtl.clock
</code></pre><p>Traits: ConstantLike</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>clock or Reset or AsyncReset</td></tr></tbody></table><h3 id=firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)&nbsp;<a class=headline-hash href=#firrtlstop-circtfirrtlstopop>¶</a></h3><p>Stop Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode custom&lt;StopAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>exitCode</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>cond</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)&nbsp;<a class=headline-hash href=#firrtlsub-circtfirrtlsubprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)&nbsp;<a class=headline-hash href=#firrtlsubaccess-circtfirrtlsubaccessop>¶</a></h3><p>Extract a dynamic element of a vector value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` type($input) `,` type($index)
</code></pre><p>The subaccess expression dynamically refers to a subelement of a
vector-typed expression using a calculated index. The index must be an
expression with an unsigned integer type.</p><pre><code>  %result = firrtl.subaccess %input[%idx] : t1, t2
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>index</code></td><td>uint type</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)&nbsp;<a class=headline-hash href=#firrtlsubfield-circtfirrtlsubfieldop>¶</a></h3><p>Extract a subfield of another value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subfield` $input `(` $fieldIndex `)` attr-dict `:` functional-type($input, $result)
</code></pre><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre><code>  %result = firrtl.subfield %input &quot;fieldIndex&quot; : t1, t2
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>fieldIndex</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>BundleType</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)&nbsp;<a class=headline-hash href=#firrtlsubindex-circtfirrtlsubindexop>¶</a></h3><p>Extract an element of a vector value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` type($input)
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre><code>  %result = firrtl.subindex %input[index] : t1
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)&nbsp;<a class=headline-hash href=#firrtltail-circtfirrtltailprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>tail</code> operation truncates the <code>amount</code> most significant bits from
<code>input</code>. <code>amount</code> must be non-negative and less than or equal to the bit
width of e. The result is <code>width(input)-amount</code> bits wide.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)&nbsp;<a class=headline-hash href=#firrtlverbatimexpr-circtfirrtlverbatimexprop>¶</a></h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre><code>operation ::= `firrtl.verbatim.expr` $text (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.expr</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>text</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>symbols</code></td><td align=center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)&nbsp;<a class=headline-hash href=#firrtlverbatimwire-circtfirrtlverbatimwireop>¶</a></h3><p>Expression with wire semantics that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre><code>operation ::= `firrtl.verbatim.wire` $text (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value with wire semantics, expressed by a
string of SystemVerilog. This can be used to access macros and other values
that are only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.wire</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>text</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>symbols</code></td><td align=center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)&nbsp;<a class=headline-hash href=#firrtlwhen-circtfirrtlwhenop>¶</a></h3><p>When Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.when` $condition $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword
</code></pre><p>The &ldquo;firrtl.when&rdquo; operation represents a conditional. Connections within
a conditional statement that connect to previously declared components hold
only when the given condition is high. The condition must have a 1-bit
unsigned integer type.</p><p>Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock</p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)&nbsp;<a class=headline-hash href=#firrtlwire-circtfirrtlwireop>¶</a></h3><p>Define a new wire</p><p>Syntax:</p><pre><code>operation ::= `firrtl.wire` (`sym` $inner_sym^)?
              custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Declare a new wire:</p><pre><code>  %name = firrtl.wire : t1
</code></pre><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>annotations</code></td><td align=center>::mlir::ArrayAttr</td><td></td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)&nbsp;<a class=headline-hash href=#firrtlxor-circtfirrtlxorprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)&nbsp;<a class=headline-hash href=#firrtlxorr-circtfirrtlxorrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;xor&rsquo; operation to merge
bits. <code>xorr(x)</code> is equivalent to <code>popcount(concat(x, 1b0)) & 1</code>. As
such, it returns 0 for zero-bit-wide operands.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=cmemoryporttype>CMemoryPortType&nbsp;<a class=headline-hash href=#cmemoryporttype>¶</a></h3><p>a behavioral memory port</p><p>Syntax:</p><pre><code>cmemoryport-type ::= `cmemoryport`
</code></pre><p>The value of a <code>cmemoryport</code> type represents a port which has been
declared on a <code>cmemory</code>. This value is used to set the memory port access
conditions.</p><h3 id=cmemorytype>CMemoryType&nbsp;<a class=headline-hash href=#cmemorytype>¶</a></h3><p>a behavioral memory</p><p>Syntax:</p><pre><code>cmemory-type ::= `cmemory` `&lt;` element-type, element-count `&gt;`
</code></pre><p>The value of a <code>cmemory</code> type represents a behavioral memory with unknown
ports. This is produced by <code>combmem</code> and <code>seqmem</code> declarations and used by
<code>memoryport</code> declarations to define memories and their ports. A CMemory is
similar to a vector of passive element types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>16</span><span class=p>&gt;</span>
<span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>bundle<span class=p>&lt;</span>a <span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>16</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-11>Parameters:&nbsp;<a class=headline-hash href=#parameters-11>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>FIRRTLType</code></td><td></td></tr><tr><td align=center>numElements</td><td align=center><code>unsigned</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ESI/ title="'esi' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'esi' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/FSM/ title="'fsm' Dialect">Next - 'fsm' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li class=active><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>