<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'hw' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/HW/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'hw' Dialect</h1><p>Types and operations for the hardware dialect
This dialect defines the <code>hw</code> dialect, which is intended to be a generic
representation of HW outside of a particular use-case.</p><p><nav id=TableOfContents><ul><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#filelistattr>FileListAttr</a></li><li><a href=#innerrefattr>InnerRefAttr</a></li><li><a href=#outputfileattr>OutputFileAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li><li><a href=#paramdeclrefattr>ParamDeclRefAttr</a></li><li><a href=#paramexprattr>ParamExprAttr</a></li><li><a href=#paramverbatimattr>ParamVerbatimAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-arraytype>an ArrayType</a></li><li><a href=#fixed-sized-array>fixed-sized array</a></li><li><a href=#an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits</a></li><li><a href=#a-type-without-inout>a type without inout</a></li><li><a href=#a-known-primitive-element>a known primitive element</a></li><li><a href=#inouttype>InOutType</a></li><li><a href=#inout-type>inout type</a></li><li><a href=#parameterized-width-integer>parameterized-width integer</a></li><li><a href=#a-structtype>a StructType</a></li><li><a href=#hw-struct-type>HW struct type</a></li><li><a href=#an-symbolic-reference-to-a-type-declaration>An symbolic reference to a type declaration</a></li><li><a href=#a-uniontype>a UnionType</a></li><li><a href=#an-untagged-union-of-types>An untagged union of types</a></li><li><a href=#systemverilog-unpacked-fixed-sized-array>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#hwarray_concat-circthwarrayconcatop>hw.array_concat (::circt::hw::ArrayConcatOp)</a></li><li><a href=#hwarray_create-circthwarraycreateop>hw.array_create (::circt::hw::ArrayCreateOp)</a></li><li><a href=#hwarray_get-circthwarraygetop>hw.array_get (::circt::hw::ArrayGetOp)</a></li><li><a href=#hwarray_slice-circthwarraysliceop>hw.array_slice (::circt::hw::ArraySliceOp)</a></li><li><a href=#hwbitcast-circthwbitcastop>hw.bitcast (::circt::hw::BitcastOp)</a></li><li><a href=#hwconstant-circthwconstantop>hw.constant (::circt::hw::ConstantOp)</a></li><li><a href=#hwgeneratorschema-circthwhwgeneratorschemaop>hw.generator.schema (::circt::hw::HWGeneratorSchemaOp)</a></li><li><a href=#hwmoduleextern-circthwhwmoduleexternop>hw.module.extern (::circt::hw::HWModuleExternOp)</a></li><li><a href=#hwmodulegenerated-circthwhwmodulegeneratedop>hw.module.generated (::circt::hw::HWModuleGeneratedOp)</a></li><li><a href=#hwmodule-circthwhwmoduleop>hw.module (::circt::hw::HWModuleOp)</a></li><li><a href=#hwinstance-circthwinstanceop>hw.instance (::circt::hw::InstanceOp)</a></li><li><a href=#hwoutput-circthwoutputop>hw.output (::circt::hw::OutputOp)</a></li><li><a href=#hwparamvalue-circthwparamvalueop>hw.param.value (::circt::hw::ParamValueOp)</a></li><li><a href=#hwstruct_create-circthwstructcreateop>hw.struct_create (::circt::hw::StructCreateOp)</a></li><li><a href=#hwstruct_explode-circthwstructexplodeop>hw.struct_explode (::circt::hw::StructExplodeOp)</a></li><li><a href=#hwstruct_extract-circthwstructextractop>hw.struct_extract (::circt::hw::StructExtractOp)</a></li><li><a href=#hwstruct_inject-circthwstructinjectop>hw.struct_inject (::circt::hw::StructInjectOp)</a></li><li><a href=#hwtype_scope-circthwtypescopeop>hw.type_scope (::circt::hw::TypeScopeOp)</a></li><li><a href=#hwtypedecl-circthwtypedeclop>hw.typedecl (::circt::hw::TypedeclOp)</a></li><li><a href=#hwunion_create-circthwunioncreateop>hw.union_create (::circt::hw::UnionCreateOp)</a></li><li><a href=#hwunion_extract-circthwunionextractop>hw.union_extract (::circt::hw::UnionExtractOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#arraytype>ArrayType</a></li><li><a href=#inouttype-1>InOutType</a></li><li><a href=#inttype>IntType</a></li><li><a href=#structtype>StructType</a></li><li><a href=#typealiastype>TypeAliasType</a></li><li><a href=#uniontype>UnionType</a></li><li><a href=#unpackedarraytype>UnpackedArrayType</a></li></ul></li></ul></nav><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=filelistattr>FileListAttr&nbsp;<a class=headline-hash href=#filelistattr>¶</a></h3><p>Ouput filelist attribute</p><p>This attribute represents an output filelist for something which will be
printed. The <code>filename</code> string is the file which the filename of the
operation to be output to.</p><p>When ExportVerilog runs, some of the files produced are lists of other files
which are produced. Each filelist exported contains entities&rsquo; output file
with <code>FileListAttr</code> marked.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>#hw.ouput_filelist</span><span class=p>&lt;</span><span class=s>&#34;/home/tester/t.F&#34;</span><span class=p>&gt;</span>
  <span class=nv>#hw.ouput_filelist</span><span class=p>&lt;</span><span class=s>&#34;t.f&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>filename</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=innerrefattr>InnerRefAttr&nbsp;<a class=headline-hash href=#innerrefattr>¶</a></h3><p>Refer to a name inside a module</p><p>This works like a symbol reference, but to a name inside a module.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>module</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>name</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=outputfileattr>OutputFileAttr&nbsp;<a class=headline-hash href=#outputfileattr>¶</a></h3><p>Ouput file attribute</p><p>This attribute represents an output file for something which will be
printed. The <code>filename</code> string is the file to be output to. If <code>filename</code>
ends in a <code>/</code> it is considered an output directory.</p><p>When ExportVerilog runs, one of the files produced is a list of all other
files which are produced. The flag <code>excludeFromFileList</code> controls if this
file should be included in this list. If any <code>OutputFileAttr</code> referring to
the same file sets this to <code>true</code>, it will be included in the file list.
This option defaults to <code>false</code>.</p><p>For each file emitted by the verilog emitter, certain prelude output will
be included before the main content. The flag <code>includeReplicatedOps</code> can
be used to disable the addition of the prelude text. All <code>OutputFileAttr</code>s
referring to the same file must use a consistent setting for this value.
This option defaults to <code>true</code>.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;/home/tester/t.sv&#34;</span><span class=p>&gt;</span>
  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;t.sv&#34;</span><span class=p>,</span> excludeFromFileList<span class=p>,</span> includeReplicatedOps<span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>filename</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>excludeFromFilelist</td><td align=center><code>::mlir::BoolAttr</code></td><td></td></tr><tr><td align=center>includeReplicatedOps</td><td align=center><code>::mlir::BoolAttr</code></td><td></td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr&nbsp;<a class=headline-hash href=#paramdeclattr>¶</a></h3><p>module or instance parameter definition</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>name</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>type</td><td align=center><code>::mlir::TypeAttr</code></td><td></td></tr><tr><td align=center>value</td><td align=center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=paramdeclrefattr>ParamDeclRefAttr&nbsp;<a class=headline-hash href=#paramdeclrefattr>¶</a></h3><p>Is a reference to a parameter value.</p><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>name</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>type</td><td align=center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramexprattr>ParamExprAttr&nbsp;<a class=headline-hash href=#paramexprattr>¶</a></h3><p>Parameter expression combining operands</p><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>opcode</td><td align=center><code>PEO</code></td><td></td></tr><tr><td align=center>operands</td><td align=center><code>::llvm::ArrayRef&lt;::mlir::Attribute></code></td><td></td></tr><tr><td align=center>type</td><td align=center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramverbatimattr>ParamVerbatimAttr&nbsp;<a class=headline-hash href=#paramverbatimattr>¶</a></h3><p>Represents text to emit directly to SystemVerilog for a parameter</p><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>value</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>type</td><td align=center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=an-arraytype>an ArrayType&nbsp;<a class=headline-hash href=#an-arraytype>¶</a></h3><h3 id=fixed-sized-array>fixed-sized array&nbsp;<a class=headline-hash href=#fixed-sized-array>¶</a></h3><p>Fixed sized HW arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h3 id=an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits&nbsp;<a class=headline-hash href=#an-integer-bitvector-of-one-or-more-bits>¶</a></h3><h3 id=a-type-without-inout>a type without inout&nbsp;<a class=headline-hash href=#a-type-without-inout>¶</a></h3><h3 id=a-known-primitive-element>a known primitive element&nbsp;<a class=headline-hash href=#a-known-primitive-element>¶</a></h3><h3 id=inouttype>InOutType&nbsp;<a class=headline-hash href=#inouttype>¶</a></h3><h3 id=inout-type>inout type&nbsp;<a class=headline-hash href=#inout-type>¶</a></h3><p>InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h3 id=parameterized-width-integer>parameterized-width integer&nbsp;<a class=headline-hash href=#parameterized-width-integer>¶</a></h3><p>Parameterized integer types are equivalent to the MLIR standard integer
type: it is signless, and may be any width integer. This type represents
the case when the width is a parameter in the HW dialect sense.</p><h3 id=a-structtype>a StructType&nbsp;<a class=headline-hash href=#a-structtype>¶</a></h3><h3 id=hw-struct-type>HW struct type&nbsp;<a class=headline-hash href=#hw-struct-type>¶</a></h3><p>Represents a structure of name, value pairs.
!hw.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h3 id=an-symbolic-reference-to-a-type-declaration>An symbolic reference to a type declaration&nbsp;<a class=headline-hash href=#an-symbolic-reference-to-a-type-declaration>¶</a></h3><p>A TypeAlias is parameterized by a SymbolRefAttr, which points to a
TypedeclOp. The root reference should refer to a TypeScope within the same
outer ModuleOp, and the leaf reference should refer to a type within that
TypeScope. A TypeAlias is further parameterized by the inner type, which is
needed to be known at the time the type is parsed.</p><p>Upon construction, a TypeAlias stores the symbol reference and type, and
canonicalizes the type to resolve any nested type aliases. The canonical
type is also cached to avoid recomputing it when needed.</p><h3 id=a-uniontype>a UnionType&nbsp;<a class=headline-hash href=#a-uniontype>¶</a></h3><h3 id=an-untagged-union-of-types>An untagged union of types&nbsp;<a class=headline-hash href=#an-untagged-union-of-types>¶</a></h3><h3 id=systemverilog-unpacked-fixed-sized-array>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array&nbsp;<a class=headline-hash href=#systemverilog-unpacked-fixed-sized-array>¶</a></h3><p>Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=hwarray_concat-circthwarrayconcatop><code>hw.array_concat</code> (::circt::hw::ArrayConcatOp)&nbsp;<a class=headline-hash href=#hwarray_concat-circthwarrayconcatop>¶</a></h3><p>Concatenate some arrays</p><p>Syntax:</p><pre><code>operation ::= `hw.array_concat` $inputs attr-dict `:` custom&lt;ArrayConcatTypes&gt;(type($inputs), type($result))
</code></pre><p>Creates an array by concatenating a variable set of arrays. One or more
values must be listed.</p><pre><code>// %a, %b, %c are hw arrays of i4 with sizes 2, 5, and 4 respectively.
%array = hw.array_concat %a, %b, %c : (2, 5, 4 x i4)
// %array is !hw.array&lt;11 x i4&gt;
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an ArrayType</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_create-circthwarraycreateop><code>hw.array_create</code> (::circt::hw::ArrayCreateOp)&nbsp;<a class=headline-hash href=#hwarray_create-circthwarraycreateop>¶</a></h3><p>Create an array from values</p><p>Creates an array from a variable set of values. One or more values must be
listed.</p><pre><code>// %a, %b, %c are all i4
%array = hw.array_create %a, %b, %c : i4
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Traits: SameTypeOperands</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_get-circthwarraygetop><code>hw.array_get</code> (::circt::hw::ArrayGetOp)&nbsp;<a class=headline-hash href=#hwarray_get-circthwarraygetop>¶</a></h3><p>Get the value in an array at the specified index</p><p>Syntax:</p><pre><code>operation ::= `hw.array_get` $input`[`$index`]` attr-dict `:` type($input)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an ArrayType</td></tr><tr><td align=center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwarray_slice-circthwarraysliceop><code>hw.array_slice</code> (::circt::hw::ArraySliceOp)&nbsp;<a class=headline-hash href=#hwarray_slice-circthwarraysliceop>¶</a></h3><p>Get a range of values from an array</p><p>Syntax:</p><pre><code>operation ::= `hw.array_slice` $input `at` $lowIndex attr-dict `:`
              `(` custom&lt;SliceTypes&gt;(type($input), type($lowIndex)) `)` `-&gt;` type($dst)
</code></pre><p>Extracts a sub-range from an array. The range is from <code>lowIndex</code> to
<code>lowIndex</code> + the number of elements in the return type, non-inclusive on
the high end. For instance,</p><pre><code>// Slices 16 elements starting at '%offset'.
%subArray = hw.slice %largerArray at %offset :
    (!hw.array&lt;1024xi8&gt;) -&gt; !hw.array&lt;16xi8&gt;
</code></pre><p>Would translate to the following SystemVerilog:</p><pre><code>logic [7:0][15:0] subArray = largerArray[offset +: 16];
</code></pre><p>Width of &lsquo;idx&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &lsquo;idx&rsquo; is ceil(log2(M)). Lower and upper bound indexes which
are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an ArrayType</td></tr><tr><td align=center><code>lowIndex</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dst</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwbitcast-circthwbitcastop><code>hw.bitcast</code> (::circt::hw::BitcastOp)&nbsp;<a class=headline-hash href=#hwbitcast-circthwbitcastop>¶</a></h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type.  See the `hw` dialect rationale document for
more details.
</code></pre><p>Syntax:</p><pre><code>operation ::= `hw.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h3 id=hwconstant-circthwconstantop><code>hw.constant</code> (::circt::hw::ConstantOp)&nbsp;<a class=headline-hash href=#hwconstant-circthwconstantop>¶</a></h3><p>Produce a constant value</p><p>The constant operation produces a constant value of standard integer type
without a sign.</p><pre><code>  %result = hw.constant 42 : t1
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), OpAsmOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=hwgeneratorschema-circthwhwgeneratorschemaop><code>hw.generator.schema</code> (::circt::hw::HWGeneratorSchemaOp)&nbsp;<a class=headline-hash href=#hwgeneratorschema-circthwhwgeneratorschemaop>¶</a></h3><p>HW Generator Schema declaration</p><p>Syntax:</p><pre><code>operation ::= `hw.generator.schema` $sym_name `,` $descriptor `,` $requiredAttrs attr-dict
</code></pre><p>The &ldquo;hw.generator.schema&rdquo; operation declares a kind of generated module by
declaring the schema of meta-data required.
A generated module instance of a schema is independent of the external
method of producing it. It is assumed that for well known schema instances,
multiple external tools might exist which can process it. Generator nodes
list attributes required by hw.module.generated instances.</p><p>For example:
generator.schema @MEMORY, &ldquo;Simple-Memory&rdquo;, [&ldquo;ports&rdquo;, &ldquo;write_latency&rdquo;, &ldquo;read_latency&rdquo;]
module.generated @mymem, @MEMORY(ports)
-> (ports) {write_latency=1, read_latency=1, ports=[&ldquo;read&rdquo;,&ldquo;write&rdquo;]}</p><p>Traits: HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: Symbol</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>descriptor</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>requiredAttrs</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h3 id=hwmoduleextern-circthwhwmoduleexternop><code>hw.module.extern</code> (::circt::hw::HWModuleExternOp)&nbsp;<a class=headline-hash href=#hwmoduleextern-circthwhwmoduleexternop>¶</a></h3><p>HW external Module</p><p>The &ldquo;hw.module.extern&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. TODO: This is a hack because we don&rsquo;t
have proper parameterization in the hw.dialect. We need a way to represent
parameterized types instead of just concrete types.</p><p>Traits: FunctionLike, HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: Symbol</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td align=center><code>verilogName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwmodulegenerated-circthwhwmodulegeneratedop><code>hw.module.generated</code> (::circt::hw::HWModuleGeneratedOp)&nbsp;<a class=headline-hash href=#hwmodulegenerated-circthwhwmodulegeneratedop>¶</a></h3><p>HW Generated Module</p><p>The &ldquo;hw.module.generated&rdquo; operation represents a reference to an external
module that will be produced by some external process.
This represents the name and list of ports to be generated.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. See hw.module for an explanation.</p><p>Traits: FunctionLike, HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a>, IsolatedFromAbove</p><p>Interfaces: Symbol</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>generatorKind</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td align=center><code>verilogName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwmodule-circthwhwmoduleop><code>hw.module</code> (::circt::hw::HWModuleOp)&nbsp;<a class=headline-hash href=#hwmodule-circthwhwmoduleop>¶</a></h3><p>HW Module</p><p>The &ldquo;hw.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, a list of parameters, and a body that represents the
connections within the module.</p><p>Traits: FunctionLike, HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a>, IsolatedFromAbove, SingleBlockImplicitTerminator<outputop></p><p>Interfaces: RegionKindInterface, Symbol</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td align=center><code>comment</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwinstance-circthwinstanceop><code>hw.instance</code> (::circt::hw::InstanceOp)&nbsp;<a class=headline-hash href=#hwinstance-circthwinstanceop>¶</a></h3><p>Create an instance of a module</p><p>This represents an instance of a module. The inputs and results are
the referenced module&rsquo;s inputs and outputs. The <code>argNames</code> and
<code>resultNames</code> attributes must match the referenced module.</p><p>Any parameters in the &ldquo;old&rdquo; format (slated to be removed) are stored in the
<code>oldParameters</code> dictionary.</p><p>Interfaces: OpAsmOpInterface, SymbolUserOpInterface</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>instanceName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>moduleName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute is module like</td></tr><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=hwoutput-circthwoutputop><code>hw.output</code> (::circt::hw::OutputOp)&nbsp;<a class=headline-hash href=#hwoutput-circthwoutputop>¶</a></h3><p>HW termination operation</p><p>Syntax:</p><pre><code>operation ::= `hw.output` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>&ldquo;hw.output&rdquo; marks the end of a region in the HW dialect and the values
to put on the output ports.</p><p>Traits: HasParent<hwmoduleop>, ReturnLike, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=hwparamvalue-circthwparamvalueop><code>hw.param.value</code> (::circt::hw::ParamValueOp)&nbsp;<a class=headline-hash href=#hwparamvalue-circthwparamvalueop>¶</a></h3><pre><code>Return the value of a parameter expression as an SSA value that may be used
by other ops.
</code></pre><p>Syntax:</p><pre><code>operation ::= `hw.param.value` custom&lt;ParamValue&gt;($value, type($result)) attr-dict
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=hwstruct_create-circthwstructcreateop><code>hw.struct_create</code> (::circt::hw::StructCreateOp)&nbsp;<a class=headline-hash href=#hwstruct_create-circthwstructcreateop>¶</a></h3><p>Create a struct from constituent parts.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwstruct_explode-circthwstructexplodeop><code>hw.struct_explode</code> (::circt::hw::StructExplodeOp)&nbsp;<a class=headline-hash href=#hwstruct_explode-circthwstructexplodeop>¶</a></h3><p>Expand a struct into its constituent parts.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwstruct_extract-circthwstructextractop><code>hw.struct_extract</code> (::circt::hw::StructExtractOp)&nbsp;<a class=headline-hash href=#hwstruct_extract-circthwstructextractop>¶</a></h3><p>Extract a named field from a struct.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwstruct_inject-circthwstructinjectop><code>hw.struct_inject</code> (::circt::hw::StructInjectOp)&nbsp;<a class=headline-hash href=#hwstruct_inject-circthwstructinjectop>¶</a></h3><p>Inject a value into a named field of a struct.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a StructType</td></tr><tr><td align=center><code>newValue</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwtype_scope-circthwtypescopeop><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)&nbsp;<a class=headline-hash href=#hwtype_scope-circthwtypescopeop>¶</a></h3><p>Type declaration wrapper.</p><p>Syntax:</p><pre><code>operation ::= `hw.type_scope` $sym_name $body attr-dict
</code></pre><p>An operation whose one body block contains type declarations. This op
provides a scope for type declarations at the top level of an MLIR module.
It is a symbol that may be looked up within the module, as well as a symbol
table itself, so type declarations may be looked up.</p><p>Traits: NoRegionArguments, NoTerminator, SingleBlock, SymbolTable</p><p>Interfaces: Symbol</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwtypedecl-circthwtypedeclop><code>hw.typedecl</code> (::circt::hw::TypedeclOp)&nbsp;<a class=headline-hash href=#hwtypedecl-circthwtypedeclop>¶</a></h3><p>Type declaration.</p><p>Syntax:</p><pre><code>operation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict
</code></pre><p>Associate a symbolic name with a type.
Traits: HasParent<typescopeop></p><p>Interfaces: Symbol</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>verilogName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwunion_create-circthwunioncreateop><code>hw.union_create</code> (::circt::hw::UnionCreateOp)&nbsp;<a class=headline-hash href=#hwunion_create-circthwunioncreateop>¶</a></h3><p>Create a union with the specified value.</p><p>Create a union with the value &lsquo;input&rsquo;, which can then be accessed via the
specified field.</p><pre><code>  %x = hw.constant 0 : i3
  %z = hw.union_create &quot;bar&quot;, %x : !hw.union&lt;bar: i3, baz: i8&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a UnionType</td></tr></tbody></table><h3 id=hwunion_extract-circthwunionextractop><code>hw.union_extract</code> (::circt::hw::UnionExtractOp)&nbsp;<a class=headline-hash href=#hwunion_extract-circthwunionextractop>¶</a></h3><p>Get a union member.</p><p>Get the value of a union, interpreting it as the type of the specified
member field. Extracting a value belonging to a different field than the
union was initially created will result in undefined behavior.</p><pre><code>  %u = ...
  %v = hw.union_extract %u[&quot;foo&quot;] : !hw.union&lt;foo: i3, bar: i16&gt;
  // %v is of type 'i3'
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p>fixed-sized array</p><p>Fixed sized HW arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h4 id=parameters-7>Parameters:&nbsp;<a class=headline-hash href=#parameters-7>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>::mlir::Type</code></td><td></td></tr><tr><td align=center>size</td><td align=center><code>size_t</code></td><td></td></tr></tbody></table><h3 id=inouttype-1>InOutType&nbsp;<a class=headline-hash href=#inouttype-1>¶</a></h3><p>inout type</p><p>InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h4 id=parameters-8>Parameters:&nbsp;<a class=headline-hash href=#parameters-8>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=inttype>IntType&nbsp;<a class=headline-hash href=#inttype>¶</a></h3><p>parameterized-width integer</p><p>Parameterized integer types are equivalent to the MLIR standard integer
type: it is signless, and may be any width integer. This type represents
the case when the width is a parameter in the HW dialect sense.</p><h4 id=parameters-9>Parameters:&nbsp;<a class=headline-hash href=#parameters-9>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>width</td><td align=center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=structtype>StructType&nbsp;<a class=headline-hash href=#structtype>¶</a></h3><p>HW struct type</p><p>Represents a structure of name, value pairs.
!hw.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h4 id=parameters-10>Parameters:&nbsp;<a class=headline-hash href=#parameters-10>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elements</td><td align=center><code>::llvm::ArrayRef&lt;::circt::hw::StructType::FieldInfo></code></td><td>struct fields</td></tr></tbody></table><h3 id=typealiastype>TypeAliasType&nbsp;<a class=headline-hash href=#typealiastype>¶</a></h3><p>An symbolic reference to a type declaration</p><p>A TypeAlias is parameterized by a SymbolRefAttr, which points to a
TypedeclOp. The root reference should refer to a TypeScope within the same
outer ModuleOp, and the leaf reference should refer to a type within that
TypeScope. A TypeAlias is further parameterized by the inner type, which is
needed to be known at the time the type is parsed.</p><p>Upon construction, a TypeAlias stores the symbol reference and type, and
canonicalizes the type to resolve any nested type aliases. The canonical
type is also cached to avoid recomputing it when needed.</p><h4 id=parameters-11>Parameters:&nbsp;<a class=headline-hash href=#parameters-11>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>ref</td><td align=center><code>mlir::SymbolRefAttr</code></td><td></td></tr><tr><td align=center>innerType</td><td align=center><code>mlir::Type</code></td><td></td></tr><tr><td align=center>canonicalType</td><td align=center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=uniontype>UnionType&nbsp;<a class=headline-hash href=#uniontype>¶</a></h3><p>An untagged union of types</p><h4 id=parameters-12>Parameters:&nbsp;<a class=headline-hash href=#parameters-12>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elements</td><td align=center><code>::llvm::ArrayRef&lt;::circt::hw::UnionType::FieldInfo></code></td><td>union fields</td></tr></tbody></table><h3 id=unpackedarraytype>UnpackedArrayType&nbsp;<a class=headline-hash href=#unpackedarraytype>¶</a></h3><p>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array</p><p>Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h4 id=parameters-13>Parameters:&nbsp;<a class=headline-hash href=#parameters-13>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>::mlir::Type</code></td><td></td></tr><tr><td align=center>size</td><td align=center><code>size_t</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Handshake/ title="'handshake' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'handshake' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/SV/ title="'hw' Dialect">Next - 'hw' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li class=active><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>