<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'msft' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/MSFT/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'msft' Dialect</h1><p>Microsoft internal support dialect
Umbrella dialect for everything needed to support Microsoft development
but not thoroughly discussed. Most (if not everything) in this dialect is
a candidate for generalization and re-homing.</p><p><nav id=TableOfContents><ul><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#physlocationattr>PhysLocationAttr</a></li><li><a href=#physicalboundsattr>PhysicalBoundsAttr</a></li><li><a href=#physicalregionrefattr>PhysicalRegionRefAttr</a></li><li><a href=#rootedinstancepathattr>RootedInstancePathAttr</a></li><li><a href=#switchinstanceattr>SwitchInstanceAttr</a></li><li><a href=#switchinstancecaseattr>SwitchInstanceCaseAttr</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#msftinstance-circtmsftinstanceop>msft.instance (::circt::msft::InstanceOp)</a></li><li><a href=#msftmoduleextern-circtmsftmsftmoduleexternop>msft.module.extern (::circt::msft::MSFTModuleExternOp)</a></li><li><a href=#msftmodule-circtmsftmsftmoduleop>msft.module (::circt::msft::MSFTModuleOp)</a></li><li><a href=#msftoutput-circtmsftoutputop>msft.output (::circt::msft::OutputOp)</a></li><li><a href=#msftphysical_region-circtmsftphysicalregionop>msft.physical_region (::circt::msft::PhysicalRegionOp)</a></li></ul></li></ul></nav><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=physlocationattr>PhysLocationAttr&nbsp;<a class=headline-hash href=#physlocationattr>¶</a></h3><p>Descibes a physical location on a device</p><p>Annotate a particular entity within an op with the location of the device
on an FPGA to which it should mapped. The coordinates in this attribute
are absolute locations on the device, so if there are two instances of a
module with this annotation incorrect results will be generated. How to
solve this is a more general, open problem.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>primitiveType</td><td align=center><code>PrimitiveTypeAttr</code></td><td></td></tr><tr><td align=center>x</td><td align=center><code>uint64_t</code></td><td></td></tr><tr><td align=center>y</td><td align=center><code>uint64_t</code></td><td></td></tr><tr><td align=center>num</td><td align=center><code>uint64_t</code></td><td></td></tr></tbody></table><h3 id=physicalboundsattr>PhysicalBoundsAttr&nbsp;<a class=headline-hash href=#physicalboundsattr>¶</a></h3><p>Describes a rectangle bounding a physical region on a device</p><p>Describes a rectangular bound within a device. The lower and upper bounds
must be specified for both the X and Y axis. The bounds are inclusive.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>xMin</td><td align=center><code>uint64_t</code></td><td></td></tr><tr><td align=center>xMax</td><td align=center><code>uint64_t</code></td><td></td></tr><tr><td align=center>yMin</td><td align=center><code>uint64_t</code></td><td></td></tr><tr><td align=center>yMax</td><td align=center><code>uint64_t</code></td><td></td></tr></tbody></table><h3 id=physicalregionrefattr>PhysicalRegionRefAttr&nbsp;<a class=headline-hash href=#physicalregionrefattr>¶</a></h3><p>Describes a reference to a physical region on a device</p><p>Annotate a particular entity within an op with the region of the devices
on an FPGA to which it should mapped. The physicalRegion must refer to a
PhysicalRegion operation.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>physicalRegion</td><td align=center><code>FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=rootedinstancepathattr>RootedInstancePathAttr&nbsp;<a class=headline-hash href=#rootedinstancepathattr>¶</a></h3><p>A path through the instance hierarchy with the root module</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>rootModule</td><td align=center><code>FlatSymbolRefAttr</code></td><td></td></tr><tr><td align=center>path</td><td align=center><code>::llvm::ArrayRef&lt;StringAttr></code></td><td></td></tr></tbody></table><h3 id=switchinstanceattr>SwitchInstanceAttr&nbsp;<a class=headline-hash href=#switchinstanceattr>¶</a></h3><p>Select an attribute to be use based on the instance</p><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>cases</td><td align=center><code>::llvm::ArrayRef&lt;SwitchInstanceCaseAttr></code></td><td></td></tr></tbody></table><h3 id=switchinstancecaseattr>SwitchInstanceCaseAttr&nbsp;<a class=headline-hash href=#switchinstancecaseattr>¶</a></h3><p>A switch case in the SwitchInstance attribute</p><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>inst</td><td align=center><code>RootedInstancePathAttr</code></td><td></td></tr><tr><td align=center>attr</td><td align=center><code>mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=msftinstance-circtmsftinstanceop><code>msft.instance</code> (::circt::msft::InstanceOp)&nbsp;<a class=headline-hash href=#msftinstance-circtmsftinstanceop>¶</a></h3><p>Instantiate a module</p><p>Syntax:</p><pre><code>operation ::= `msft.instance` $sym_name $moduleName `(` $inputs `)` custom&lt;ParameterList&gt;($parameters) attr-dict
              `:` functional-type($inputs, results)
</code></pre><p>Traits: HasParent&lt;::circt::hw::HWModuleOp, MSFTModuleOp></p><p>Interfaces: OpAsmOpInterface, Symbol, SymbolUserOpInterface</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>moduleName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=msftmoduleextern-circtmsftmsftmoduleexternop><code>msft.module.extern</code> (::circt::msft::MSFTModuleExternOp)&nbsp;<a class=headline-hash href=#msftmoduleextern-circtmsftmsftmoduleexternop>¶</a></h3><p>MSFT external Module</p><p>Identical to <code>hw.module.extern</code>, and trivially lowers to that. This op
exists so that we can use <code>msft.instance</code> to refer to both <code>msft.module</code> and
<code>msft.module.extern</code>, rather than mixing <code>hw.instance</code> with <code>msft.instance</code>.</p><p>Traits: HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: Symbol</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::ArrayAttr</td><td>parameter array</td></tr><tr><td align=center><code>verilogName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=msftmodule-circtmsftmsftmoduleop><code>msft.module</code> (::circt::msft::MSFTModuleOp)&nbsp;<a class=headline-hash href=#msftmodule-circtmsftmsftmoduleop>¶</a></h3><p>MSFT HW Module</p><p>A lot like <code>hw.module</code>, but with a few differences:</p><ul><li>Can exist without a body. The body is filled in by a generator post op
creation.</li><li>MSFT-specific methods and arguments will be added later on.</li></ul><p>Traits: FunctionLike, HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a>, IsolatedFromAbove</p><p>Interfaces: RegionKindInterface, Symbol</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>argNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>resultNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr><tr><td align=center><code>fileName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=msftoutput-circtmsftoutputop><code>msft.output</code> (::circt::msft::OutputOp)&nbsp;<a class=headline-hash href=#msftoutput-circtmsftoutputop>¶</a></h3><p>termination operation</p><p>Syntax:</p><pre><code>operation ::= `msft.output` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>Traits: HasParent<msftmoduleop>, ReturnLike, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=msftphysical_region-circtmsftphysicalregionop><code>msft.physical_region</code> (::circt::msft::PhysicalRegionOp)&nbsp;<a class=headline-hash href=#msftphysical_region-circtmsftphysicalregionop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `msft.physical_region` $sym_name `,` $bounds attr-dict
</code></pre><p>Traits: HasParent<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: Symbol</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>bounds</code></td><td align=center>::mlir::ArrayAttr</td><td>array of PhysicalBounds</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Moore/ title="'moore' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'moore' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Seq/ title="'seq' Dialect">Next - 'seq' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li class=active><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>