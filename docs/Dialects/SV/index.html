<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'hw' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SV/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'hw' Dialect</h1><p>Types and operations for the hardware dialect
This dialect defines the <code>hw</code> dialect, which is intended to be a generic
representation of HW outside of a particular use-case.</p><p><nav id=TableOfContents><ul><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#innerrefattr>InnerRefAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-arraytype>an ArrayType</a></li><li><a href=#an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits</a></li><li><a href=#a-type-without-inout>a type without inout</a></li><li><a href=#a-known-primitive-element>a known primitive element</a></li><li><a href=#inouttype>InOutType</a></li><li><a href=#a-structtype>a StructType</a></li><li><a href=#a-uniontype>a UnionType</a></li></ul></li></ul><ul><li><a href=#type-constraint-definition-1>Type constraint definition</a><ul><li><a href=#systemverilog-interface-type-pointing-to-an-interfaceop>SystemVerilog interface type pointing to an InterfaceOp</a></li><li><a href=#systemverilog-type-pointing-to-an-interfacemodportop>SystemVerilog type pointing to an InterfaceModportOp</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#svalias-circtsvaliasop>sv.alias (::circt::sv::AliasOp)</a></li><li><a href=#svalwayscomb-circtsvalwayscombop>sv.alwayscomb (::circt::sv::AlwaysCombOp)</a></li><li><a href=#svalwaysff-circtsvalwaysffop>sv.alwaysff (::circt::sv::AlwaysFFOp)</a></li><li><a href=#svalways-circtsvalwaysop>sv.always (::circt::sv::AlwaysOp)</a></li><li><a href=#svarray_index_inout-circtsvarrayindexinoutop>sv.array_index_inout (::circt::sv::ArrayIndexInOutOp)</a></li><li><a href=#svassertconcurrent-circtsvassertconcurrentop>sv.assert.concurrent (::circt::sv::AssertConcurrentOp)</a></li><li><a href=#svassert-circtsvassertop>sv.assert (::circt::sv::AssertOp)</a></li><li><a href=#svinterfacesignalassign-circtsvassigninterfacesignalop>sv.interface.signal.assign (::circt::sv::AssignInterfaceSignalOp)</a></li><li><a href=#svassign-circtsvassignop>sv.assign (::circt::sv::AssignOp)</a></li><li><a href=#svassumeconcurrent-circtsvassumeconcurrentop>sv.assume.concurrent (::circt::sv::AssumeConcurrentOp)</a></li><li><a href=#svassume-circtsvassumeop>sv.assume (::circt::sv::AssumeOp)</a></li><li><a href=#svbpassign-circtsvbpassignop>sv.bpassign (::circt::sv::BPAssignOp)</a></li><li><a href=#svbindinterface-circtsvbindinterfaceop>sv.bind.interface (::circt::sv::BindInterfaceOp)</a></li><li><a href=#svbind-circtsvbindop>sv.bind (::circt::sv::BindOp)</a></li><li><a href=#svcasez-circtsvcasezop>sv.casez (::circt::sv::CaseZOp)</a></li><li><a href=#svconstantx-circtsvconstantxop>sv.constantX (::circt::sv::ConstantXOp)</a></li><li><a href=#svconstantz-circtsvconstantzop>sv.constantZ (::circt::sv::ConstantZOp)</a></li><li><a href=#svcoverconcurrent-circtsvcoverconcurrentop>sv.cover.concurrent (::circt::sv::CoverConcurrentOp)</a></li><li><a href=#svcover-circtsvcoverop>sv.cover (::circt::sv::CoverOp)</a></li><li><a href=#sverror-circtsverrorop>sv.error (::circt::sv::ErrorOp)</a></li><li><a href=#svexit-circtsvexitop>sv.exit (::circt::sv::ExitOp)</a></li><li><a href=#svfwrite-circtsvfwriteop>sv.fwrite (::circt::sv::FWriteOp)</a></li><li><a href=#svfatal-circtsvfatalop>sv.fatal (::circt::sv::FatalOp)</a></li><li><a href=#svfinish-circtsvfinishop>sv.finish (::circt::sv::FinishOp)</a></li><li><a href=#svforce-circtsvforceop>sv.force (::circt::sv::ForceOp)</a></li><li><a href=#svmodportget-circtsvgetmodportop>sv.modport.get (::circt::sv::GetModportOp)</a></li><li><a href=#svifdef-circtsvifdefop>sv.ifdef (::circt::sv::IfDefOp)</a></li><li><a href=#svifdefprocedural-circtsvifdefproceduralop>sv.ifdef.procedural (::circt::sv::IfDefProceduralOp)</a></li><li><a href=#svif-circtsvifop>sv.if (::circt::sv::IfOp)</a></li><li><a href=#svindexed_part_select_inout-circtsvindexedpartselectinoutop>sv.indexed_part_select_inout (::circt::sv::IndexedPartSelectInOutOp)</a></li><li><a href=#svindexed_part_select-circtsvindexedpartselectop>sv.indexed_part_select (::circt::sv::IndexedPartSelectOp)</a></li><li><a href=#svinfo-circtsvinfoop>sv.info (::circt::sv::InfoOp)</a></li><li><a href=#svinitial-circtsvinitialop>sv.initial (::circt::sv::InitialOp)</a></li><li><a href=#svinterfaceinstance-circtsvinterfaceinstanceop>sv.interface.instance (::circt::sv::InterfaceInstanceOp)</a></li><li><a href=#svinterfacemodport-circtsvinterfacemodportop>sv.interface.modport (::circt::sv::InterfaceModportOp)</a></li><li><a href=#svinterface-circtsvinterfaceop>sv.interface (::circt::sv::InterfaceOp)</a></li><li><a href=#svinterfacesignal-circtsvinterfacesignalop>sv.interface.signal (::circt::sv::InterfaceSignalOp)</a></li><li><a href=#svlocalparam-circtsvlocalparamop>sv.localparam (::circt::sv::LocalParamOp)</a></li><li><a href=#svpassign-circtsvpassignop>sv.passign (::circt::sv::PAssignOp)</a></li><li><a href=#svread_inout-circtsvreadinoutop>sv.read_inout (::circt::sv::ReadInOutOp)</a></li><li><a href=#svinterfacesignalread-circtsvreadinterfacesignalop>sv.interface.signal.read (::circt::sv::ReadInterfaceSignalOp)</a></li><li><a href=#svreg-circtsvregop>sv.reg (::circt::sv::RegOp)</a></li><li><a href=#svrelease-circtsvreleaseop>sv.release (::circt::sv::ReleaseOp)</a></li><li><a href=#svstop-circtsvstopop>sv.stop (::circt::sv::StopOp)</a></li><li><a href=#svverbatimexpr-circtsvverbatimexprop>sv.verbatim.expr (::circt::sv::VerbatimExprOp)</a></li><li><a href=#svverbatimexprse-circtsvverbatimexprseop>sv.verbatim.expr.se (::circt::sv::VerbatimExprSEOp)</a></li><li><a href=#svverbatim-circtsvverbatimop>sv.verbatim (::circt::sv::VerbatimOp)</a></li><li><a href=#svwarning-circtsvwarningop>sv.warning (::circt::sv::WarningOp)</a></li><li><a href=#svwire-circtsvwireop>sv.wire (::circt::sv::WireOp)</a></li><li><a href=#svxmr-circtsvxmrop>sv.xmr (::circt::sv::XMROp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#interfacetype>InterfaceType</a></li><li><a href=#modporttype>ModportType</a></li></ul></li></ul></nav><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=innerrefattr>InnerRefAttr&nbsp;<a class=headline-hash href=#innerrefattr>¶</a></h3><p>Refer to a name inside a module</p><p>This works like a symbol reference, but to a name inside a module.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>module</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td align=center>name</td><td align=center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=an-arraytype>an ArrayType&nbsp;<a class=headline-hash href=#an-arraytype>¶</a></h3><h3 id=an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits&nbsp;<a class=headline-hash href=#an-integer-bitvector-of-one-or-more-bits>¶</a></h3><h3 id=a-type-without-inout>a type without inout&nbsp;<a class=headline-hash href=#a-type-without-inout>¶</a></h3><h3 id=a-known-primitive-element>a known primitive element&nbsp;<a class=headline-hash href=#a-known-primitive-element>¶</a></h3><h3 id=inouttype>InOutType&nbsp;<a class=headline-hash href=#inouttype>¶</a></h3><h3 id=a-structtype>a StructType&nbsp;<a class=headline-hash href=#a-structtype>¶</a></h3><h3 id=a-uniontype>a UnionType&nbsp;<a class=headline-hash href=#a-uniontype>¶</a></h3><h1 id=sv-dialect>&lsquo;sv&rsquo; Dialect</h1><p>Types and operations for SV dialect
This dialect defines the <code>sv</code> dialect, which represents various
SystemVerilog-specific constructs in an AST-like representation.</p><p><nav id=TableOfContents><ul><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#innerrefattr>InnerRefAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-arraytype>an ArrayType</a></li><li><a href=#an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits</a></li><li><a href=#a-type-without-inout>a type without inout</a></li><li><a href=#a-known-primitive-element>a known primitive element</a></li><li><a href=#inouttype>InOutType</a></li><li><a href=#a-structtype>a StructType</a></li><li><a href=#a-uniontype>a UnionType</a></li></ul></li></ul><ul><li><a href=#type-constraint-definition-1>Type constraint definition</a><ul><li><a href=#systemverilog-interface-type-pointing-to-an-interfaceop>SystemVerilog interface type pointing to an InterfaceOp</a></li><li><a href=#systemverilog-type-pointing-to-an-interfacemodportop>SystemVerilog type pointing to an InterfaceModportOp</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#svalias-circtsvaliasop>sv.alias (::circt::sv::AliasOp)</a></li><li><a href=#svalwayscomb-circtsvalwayscombop>sv.alwayscomb (::circt::sv::AlwaysCombOp)</a></li><li><a href=#svalwaysff-circtsvalwaysffop>sv.alwaysff (::circt::sv::AlwaysFFOp)</a></li><li><a href=#svalways-circtsvalwaysop>sv.always (::circt::sv::AlwaysOp)</a></li><li><a href=#svarray_index_inout-circtsvarrayindexinoutop>sv.array_index_inout (::circt::sv::ArrayIndexInOutOp)</a></li><li><a href=#svassertconcurrent-circtsvassertconcurrentop>sv.assert.concurrent (::circt::sv::AssertConcurrentOp)</a></li><li><a href=#svassert-circtsvassertop>sv.assert (::circt::sv::AssertOp)</a></li><li><a href=#svinterfacesignalassign-circtsvassigninterfacesignalop>sv.interface.signal.assign (::circt::sv::AssignInterfaceSignalOp)</a></li><li><a href=#svassign-circtsvassignop>sv.assign (::circt::sv::AssignOp)</a></li><li><a href=#svassumeconcurrent-circtsvassumeconcurrentop>sv.assume.concurrent (::circt::sv::AssumeConcurrentOp)</a></li><li><a href=#svassume-circtsvassumeop>sv.assume (::circt::sv::AssumeOp)</a></li><li><a href=#svbpassign-circtsvbpassignop>sv.bpassign (::circt::sv::BPAssignOp)</a></li><li><a href=#svbindinterface-circtsvbindinterfaceop>sv.bind.interface (::circt::sv::BindInterfaceOp)</a></li><li><a href=#svbind-circtsvbindop>sv.bind (::circt::sv::BindOp)</a></li><li><a href=#svcasez-circtsvcasezop>sv.casez (::circt::sv::CaseZOp)</a></li><li><a href=#svconstantx-circtsvconstantxop>sv.constantX (::circt::sv::ConstantXOp)</a></li><li><a href=#svconstantz-circtsvconstantzop>sv.constantZ (::circt::sv::ConstantZOp)</a></li><li><a href=#svcoverconcurrent-circtsvcoverconcurrentop>sv.cover.concurrent (::circt::sv::CoverConcurrentOp)</a></li><li><a href=#svcover-circtsvcoverop>sv.cover (::circt::sv::CoverOp)</a></li><li><a href=#sverror-circtsverrorop>sv.error (::circt::sv::ErrorOp)</a></li><li><a href=#svexit-circtsvexitop>sv.exit (::circt::sv::ExitOp)</a></li><li><a href=#svfwrite-circtsvfwriteop>sv.fwrite (::circt::sv::FWriteOp)</a></li><li><a href=#svfatal-circtsvfatalop>sv.fatal (::circt::sv::FatalOp)</a></li><li><a href=#svfinish-circtsvfinishop>sv.finish (::circt::sv::FinishOp)</a></li><li><a href=#svforce-circtsvforceop>sv.force (::circt::sv::ForceOp)</a></li><li><a href=#svmodportget-circtsvgetmodportop>sv.modport.get (::circt::sv::GetModportOp)</a></li><li><a href=#svifdef-circtsvifdefop>sv.ifdef (::circt::sv::IfDefOp)</a></li><li><a href=#svifdefprocedural-circtsvifdefproceduralop>sv.ifdef.procedural (::circt::sv::IfDefProceduralOp)</a></li><li><a href=#svif-circtsvifop>sv.if (::circt::sv::IfOp)</a></li><li><a href=#svindexed_part_select_inout-circtsvindexedpartselectinoutop>sv.indexed_part_select_inout (::circt::sv::IndexedPartSelectInOutOp)</a></li><li><a href=#svindexed_part_select-circtsvindexedpartselectop>sv.indexed_part_select (::circt::sv::IndexedPartSelectOp)</a></li><li><a href=#svinfo-circtsvinfoop>sv.info (::circt::sv::InfoOp)</a></li><li><a href=#svinitial-circtsvinitialop>sv.initial (::circt::sv::InitialOp)</a></li><li><a href=#svinterfaceinstance-circtsvinterfaceinstanceop>sv.interface.instance (::circt::sv::InterfaceInstanceOp)</a></li><li><a href=#svinterfacemodport-circtsvinterfacemodportop>sv.interface.modport (::circt::sv::InterfaceModportOp)</a></li><li><a href=#svinterface-circtsvinterfaceop>sv.interface (::circt::sv::InterfaceOp)</a></li><li><a href=#svinterfacesignal-circtsvinterfacesignalop>sv.interface.signal (::circt::sv::InterfaceSignalOp)</a></li><li><a href=#svlocalparam-circtsvlocalparamop>sv.localparam (::circt::sv::LocalParamOp)</a></li><li><a href=#svpassign-circtsvpassignop>sv.passign (::circt::sv::PAssignOp)</a></li><li><a href=#svread_inout-circtsvreadinoutop>sv.read_inout (::circt::sv::ReadInOutOp)</a></li><li><a href=#svinterfacesignalread-circtsvreadinterfacesignalop>sv.interface.signal.read (::circt::sv::ReadInterfaceSignalOp)</a></li><li><a href=#svreg-circtsvregop>sv.reg (::circt::sv::RegOp)</a></li><li><a href=#svrelease-circtsvreleaseop>sv.release (::circt::sv::ReleaseOp)</a></li><li><a href=#svstop-circtsvstopop>sv.stop (::circt::sv::StopOp)</a></li><li><a href=#svverbatimexpr-circtsvverbatimexprop>sv.verbatim.expr (::circt::sv::VerbatimExprOp)</a></li><li><a href=#svverbatimexprse-circtsvverbatimexprseop>sv.verbatim.expr.se (::circt::sv::VerbatimExprSEOp)</a></li><li><a href=#svverbatim-circtsvverbatimop>sv.verbatim (::circt::sv::VerbatimOp)</a></li><li><a href=#svwarning-circtsvwarningop>sv.warning (::circt::sv::WarningOp)</a></li><li><a href=#svwire-circtsvwireop>sv.wire (::circt::sv::WireOp)</a></li><li><a href=#svxmr-circtsvxmrop>sv.xmr (::circt::sv::XMROp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#interfacetype>InterfaceType</a></li><li><a href=#modporttype>ModportType</a></li></ul></li></ul></nav><h2 id=type-constraint-definition-1>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition-1>¶</a></h2><h3 id=systemverilog-interface-type-pointing-to-an-interfaceop>SystemVerilog interface type pointing to an InterfaceOp&nbsp;<a class=headline-hash href=#systemverilog-interface-type-pointing-to-an-interfaceop>¶</a></h3><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h3 id=systemverilog-type-pointing-to-an-interfacemodportop>SystemVerilog type pointing to an InterfaceModportOp&nbsp;<a class=headline-hash href=#systemverilog-type-pointing-to-an-interfacemodportop>¶</a></h3><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)&nbsp;<a class=headline-hash href=#svalias-circtsvaliasop>¶</a></h3><p>SystemVerilog &lsquo;alias&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.alias` $operands attr-dict `:` type($operands)
</code></pre><p>An alias statement declares multiple names for the same physical net, or
bits within a net. Aliases always have at least two operands.</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>InOutType</td></tr></tbody></table><h3 id=svalwayscomb-circtsvalwayscombop><code>sv.alwayscomb</code> (::circt::sv::AlwaysCombOp)&nbsp;<a class=headline-hash href=#svalwayscomb-circtsvalwayscombop>¶</a></h3><p>&lsquo;alwayscomb block</p><p>Syntax:</p><pre><code>operation ::= `sv.alwayscomb` $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.2.2.2.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h3 id=svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)&nbsp;<a class=headline-hash href=#svalwaysff-circtsvalwaysffop>¶</a></h3><p>&lsquo;alwaysff @&rsquo; block with optional reset</p><p>Syntax:</p><pre><code>operation ::= `sv.alwaysff` `(` $clockEdge $clock `)` $bodyBlk
              ( `(` $resetStyle `:` $resetEdge^ $reset `)` $resetBlk )? attr-dict
</code></pre><p>alwaysff blocks represent always_ff verilog nodes, which enforce inference
of registers. This block takes a clock signal and edge sensitivity and
reset type. If the reset type is anything but &lsquo;noreset&rsquo;, the block takes a
reset signal, reset sensitivity, and reset block. Appropriate if conditions
are generated in the output code based on the reset type. A negative-edge,
asynchronous reset will check the inverse of the reset condition
(if (!reset) begin resetblock end) to match the sensitivity.</p><p>Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockEdge</code></td><td align=center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td align=center><code>resetStyle</code></td><td align=center>::ResetTypeAttr</td><td>reset type</td></tr><tr><td align=center><code>resetEdge</code></td><td align=center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>reset</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)&nbsp;<a class=headline-hash href=#svalways-circtsvalwaysop>¶</a></h3><p>&lsquo;always @&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.always` custom&lt;EventList&gt;($events, $clocks) $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.4.2.2.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>events</code></td><td align=center>::mlir::ArrayAttr</td><td>events</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clocks</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)&nbsp;<a class=headline-hash href=#svarray_index_inout-circtsvarrayindexinoutop>¶</a></h3><p>Index an inout memory to produce an inout element</p><p>Syntax:</p><pre><code>operation ::= `sv.array_index_inout` $input`[`$index`]` attr-dict `:` type($input) `,` type($index)
</code></pre><p>See SV Spec 11.5.2.
Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an inout type with array element</td></tr><tr><td align=center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svassertconcurrent-circtsvassertconcurrentop><code>sv.assert.concurrent</code> (::circt::sv::AssertConcurrentOp)&nbsp;<a class=headline-hash href=#svassertconcurrent-circtsvassertconcurrentop>¶</a></h3><p>concurrent assertion statement, i.e., assert property</p><p>Syntax:</p><pre><code>operation ::= `sv.assert.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a property of the hardware design is true whenever the property
is evaluated. This can be used to both document the behavior of the design
and to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>event</code></td><td align=center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)&nbsp;<a class=headline-hash href=#svassert-circtsvassertop>¶</a></h3><p>immediate assertion statement</p><p>Syntax:</p><pre><code>operation ::= `sv.assert` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression is always true. This can be used to both
document the behavior of the design and to test that the design behaves as
expected. See Section 16.3 of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defer</code></td><td align=center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignalassign-circtsvassigninterfacesignalop>¶</a></h3><p>Assign an interfaces signal to some other signal.</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal.assign` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              `=` $rhs attr-dict `:` type($rhs)
</code></pre><p>Use this to continuously assign a signal inside an interface to a
value or other signal.</p><pre><code>  sv.interface.signal.assign %iface(@handshake_example::@data)
    = %zero32 : i32
</code></pre><p>Would result in the following SystemVerilog:</p><pre><code>  assign iface.data = zero32;
</code></pre><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr><tr><td align=center><code>rhs</code></td><td>any type</td></tr></tbody></table><h3 id=svassign-circtsvassignop><code>sv.assign</code> (::circt::sv::AssignOp)&nbsp;<a class=headline-hash href=#svassign-circtsvassignop>¶</a></h3><p>Continuous assignment</p><p>Syntax:</p><pre><code>operation ::= `sv.assign` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog assignment statement &lsquo;x = y;'.
These occur in module scope. See SV Spec 10.3.2.</p><p>Traits: NonProceduralOp</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svassumeconcurrent-circtsvassumeconcurrentop><code>sv.assume.concurrent</code> (::circt::sv::AssumeConcurrentOp)&nbsp;<a class=headline-hash href=#svassumeconcurrent-circtsvassumeconcurrentop>¶</a></h3><p>concurrent assume statement, i.e., assume property</p><p>Syntax:</p><pre><code>operation ::= `sv.assume.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a property is assumed to be true whenever the property is
evaluated. This can be used to both document the behavior of the design and
to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>event</code></td><td align=center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)&nbsp;<a class=headline-hash href=#svassume-circtsvassumeop>¶</a></h3><p>immediate assume statement</p><p>Syntax:</p><pre><code>operation ::= `sv.assume` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression is assumed to always be true. This can
either be used as an assertion-like check that the expression is, in fact,
always true or to bound legal input values during testing. See Section 16.3
of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defer</code></td><td align=center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)&nbsp;<a class=headline-hash href=#svbpassign-circtsvbpassignop>¶</a></h3><p>Blocking procedural assignment</p><p>Syntax:</p><pre><code>operation ::= `sv.bpassign` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog blocking procedural assignment statement &lsquo;x = y;'. These
occur in initial, always, task, and function blocks. The statement is
executed before any following statements are. See SV Spec 10.4.1.</p><p>Traits: ProceduralOp</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svbindinterface-circtsvbindinterfaceop><code>sv.bind.interface</code> (::circt::sv::BindInterfaceOp)&nbsp;<a class=headline-hash href=#svbindinterface-circtsvbindinterfaceop>¶</a></h3><p>indirectly instantiate an interface</p><p>Syntax:</p><pre><code>operation ::= `sv.bind.interface` $interface attr-dict
</code></pre><p>Indirectly instantiate an interface in the context of another module. This
operation must pair with a <code>sv.interface.instance</code>.</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>interface</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h3 id=svbind-circtsvbindop><code>sv.bind</code> (::circt::sv::BindOp)&nbsp;<a class=headline-hash href=#svbind-circtsvbindop>¶</a></h3><p>indirect instantiation statement</p><p>Syntax:</p><pre><code>operation ::= `sv.bind` $instance attr-dict
</code></pre><p>Indirectly instantiate a module from the context of another module. BindOp
pairs with a <code>hw.instance</code> (identified by a <code>boundInstance</code> symbol) which
tracks all information except the emission point for the bind. BindOp also
tracks the <code>instanceModule</code> symbol for the <code>hw.module</code> that contains the
<code>hw.instance</code> to accelerate symbol lookup.</p><p>See 23.11 of SV 2017 spec for more information about bind.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>instance</code></td><td align=center>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></tbody></table><h3 id=svcasez-circtsvcasezop><code>sv.casez</code> (::circt::sv::CaseZOp)&nbsp;<a class=headline-hash href=#svcasez-circtsvcasezop>¶</a></h3><p>&lsquo;casez (cond)&rsquo; block</p><p>See SystemVerilog 2017 12.5.1.
Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>casePatterns</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=svconstantx-circtsvconstantxop><code>sv.constantX</code> (::circt::sv::ConstantXOp)&nbsp;<a class=headline-hash href=#svconstantx-circtsvconstantxop>¶</a></h3><p>A constant of value &lsquo;x&rsquo;</p><p>Syntax:</p><pre><code>operation ::= `sv.constantX` attr-dict `:` type($result)
</code></pre><p>This operation produces a constant value of &lsquo;x&rsquo;. This &lsquo;x&rsquo; follows the
System Verilog rules for &lsquo;x&rsquo; propagation.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=svconstantz-circtsvconstantzop><code>sv.constantZ</code> (::circt::sv::ConstantZOp)&nbsp;<a class=headline-hash href=#svconstantz-circtsvconstantzop>¶</a></h3><p>A constant of value &lsquo;z&rsquo;</p><p>Syntax:</p><pre><code>operation ::= `sv.constantZ` attr-dict `:` type($result)
</code></pre><p>This operation produces a constant value of &lsquo;z&rsquo;. This &lsquo;z&rsquo; follows the
System Verilog rules for &lsquo;z&rsquo; propagation.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=svcoverconcurrent-circtsvcoverconcurrentop><code>sv.cover.concurrent</code> (::circt::sv::CoverConcurrentOp)&nbsp;<a class=headline-hash href=#svcoverconcurrent-circtsvcoverconcurrentop>¶</a></h3><p>concurrent cover statement, i.e., cover property</p><p>Syntax:</p><pre><code>operation ::= `sv.cover.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a specific property should be monitored for coverage, i.e., a
simulation will watch if it occurrs and how many times it occurs. See
section 16.5 of the SystemVerilog 2017 specification.</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>event</code></td><td align=center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)&nbsp;<a class=headline-hash href=#svcover-circtsvcoverop>¶</a></h3><p>immediate cover statement</p><p>Syntax:</p><pre><code>operation ::= `sv.cover` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression should be monitored for coverage, i.e., a
simulator will watch if it occurs and how many times it occurs. See section
16.3 of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defer</code></td><td align=center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td align=center><code>label</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=sverror-circtsverrorop><code>sv.error</code> (::circt::sv::ErrorOp)&nbsp;<a class=headline-hash href=#sverror-circtsverrorop>¶</a></h3><p><code>$error</code> severity message task</p><p>Syntax:</p><pre><code>operation ::= `sv.error` ($message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time error.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svexit-circtsvexitop><code>sv.exit</code> (::circt::sv::ExitOp)&nbsp;<a class=headline-hash href=#svexit-circtsvexitop>¶</a></h3><p><code>$exit</code> system task</p><p>Syntax:</p><pre><code>operation ::= `sv.exit` attr-dict
</code></pre><p>Waits for all <code>program</code> blocks to complete and then makes an implicit call
to <code>$finish</code> with default verbosity (level 1) to conclude the simulation.</p><p>Traits: ProceduralOp</p><h3 id=svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)&nbsp;<a class=headline-hash href=#svfwrite-circtsvfwriteop>¶</a></h3><p>&lsquo;$fwrite&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.fwrite` $string attr-dict (`(` $operands^ `)` `:` type($operands))?
</code></pre><p>Traits: ProceduralOp</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)&nbsp;<a class=headline-hash href=#svfatal-circtsvfatalop>¶</a></h3><p><code>$fatal</code> severity message task</p><p>Syntax:</p><pre><code>operation ::= `sv.fatal` $verbosity
              (`,` $message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>Generates a run-time fatal error which terminates the simulation with an
error code. Makes an implicit call to <code>$finish</code>, forwarding the <code>verbosity</code>
operand. If present, the optional message is printed with any additional
operands interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>verbosity</code></td><td align=center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)&nbsp;<a class=headline-hash href=#svfinish-circtsvfinishop>¶</a></h3><p><code>$finish</code> system task</p><p>Syntax:</p><pre><code>operation ::= `sv.finish` $verbosity attr-dict
</code></pre><p>Stops the simulation and exits/terminates the simulator process. In practice
most GUI-based simulators will show a prompt to the user offering them an
opportunity to not close the simulator altogether.</p><p>Other tasks such as <code>$exit</code> or <code>$fatal</code> implicitly call this system task.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: ProceduralOp</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>verbosity</code></td><td align=center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></tbody></table><h3 id=svforce-circtsvforceop><code>sv.force</code> (::circt::sv::ForceOp)&nbsp;<a class=headline-hash href=#svforce-circtsvforceop>¶</a></h3><p>Force procedural statement</p><p>Syntax:</p><pre><code>operation ::= `sv.force` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog force procedural statement &lsquo;force x = y;'. These
occur in initial, always, task, and function blocks.
A force statement shall override a procedural assignment until
a release statement is executed on the variable.
The left-hand side of the assignment can be avariable, a net,
a constant bit-select of a vector net, a part-select of a vector
net or a concatenation. It cannot be a memory word or a bit-select
or part-select of a vector variable. See SV Spec 10.6.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)&nbsp;<a class=headline-hash href=#svmodportget-circtsvgetmodportop>¶</a></h3><p>Get a modport out of an interface instance</p><p>Syntax:</p><pre><code>operation ::= `sv.modport.get` $iface $field attr-dict `:` type($iface) `-&gt;` type($result)
</code></pre><p>Use this to extract a modport view to an instantiated interface. For
example, to get the &lsquo;dataflow_in&rsquo; modport on the &lsquo;handshake_example&rsquo;
interface:</p><pre><code>%ifaceModport = sv.modport.get @dataflow_in %iface :
  !sv.interface&lt;@handshake_example&gt; -&gt;
  !sv.modport&lt;@handshake_example::@dataflow_in&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>SystemVerilog type pointing to an InterfaceModportOp</td></tr></tbody></table><h3 id=svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)&nbsp;<a class=headline-hash href=#svifdef-circtsvifdefop>¶</a></h3><p>&lsquo;ifdef MACRO&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.ifdef` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for non-procedural regions and its body is non-procedural.</p><p>Traits: NoRegionArguments, NoTerminator, NonProceduralOp, SingleBlock</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svifdefprocedural-circtsvifdefproceduralop><code>sv.ifdef.procedural</code> (::circt::sv::IfDefProceduralOp)&nbsp;<a class=headline-hash href=#svifdefprocedural-circtsvifdefproceduralop>¶</a></h3><p>&lsquo;ifdef MACRO&rsquo; block for procedural regions</p><p>Syntax:</p><pre><code>operation ::= `sv.ifdef.procedural` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for procedural regions and its body is procedural.</p><p>Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)&nbsp;<a class=headline-hash href=#svif-circtsvifop>¶</a></h3><p>&lsquo;if (cond)&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.if` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svindexed_part_select_inout-circtsvindexedpartselectinoutop><code>sv.indexed_part_select_inout</code> (::circt::sv::IndexedPartSelectInOutOp)&nbsp;<a class=headline-hash href=#svindexed_part_select_inout-circtsvindexedpartselectinoutop>¶</a></h3><p>Address several contiguous bits of an inout type (e.g. a wire or inout port). This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</p><p>Syntax:</p><pre><code>operation ::= `sv.indexed_part_select_inout` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` type($input) `,` type($base)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>width</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>decrement</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>InOutType</td></tr><tr><td align=center><code>base</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svindexed_part_select-circtsvindexedpartselectop><code>sv.indexed_part_select</code> (::circt::sv::IndexedPartSelectOp)&nbsp;<a class=headline-hash href=#svindexed_part_select-circtsvindexedpartselectop>¶</a></h3><p>Read several contiguous bits of an int type.This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</p><p>Syntax:</p><pre><code>operation ::= `sv.indexed_part_select` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` type($input) `,` type($base)
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>width</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>decrement</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>base</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=svinfo-circtsvinfoop><code>sv.info</code> (::circt::sv::InfoOp)&nbsp;<a class=headline-hash href=#svinfo-circtsvinfoop>¶</a></h3><p><code>$info</code> severity message task</p><p>Syntax:</p><pre><code>operation ::= `sv.info` ($message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>This system task indicates a message with no specific severity.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)&nbsp;<a class=headline-hash href=#svinitial-circtsvinitialop>¶</a></h3><p>&lsquo;initial&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.initial` $body attr-dict
</code></pre><p>See SV Spec 9.2.1.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h3 id=svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)&nbsp;<a class=headline-hash href=#svinterfaceinstance-circtsvinterfaceinstanceop>¶</a></h3><p>Instantiate an interface</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.instance` (`sym` $sym_name^)? custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Use this to declare an instance of an interface:</p><pre><code>%iface = sv.interface.instance : !sv.interface&lt;@handshake_example&gt;
</code></pre><p>Interfaces: Symbol</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h3 id=svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)&nbsp;<a class=headline-hash href=#svinterfacemodport-circtsvinterfacemodportop>¶</a></h3><p>Operation to define a SystemVerilog modport for interfaces</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.modport` attr-dict $sym_name custom&lt;ModportStructs&gt;($ports)
</code></pre><p>This operation defines a named modport within an interface. Its name is a
symbol that can be looked up inside its parent interface. There is an array
of structs that contains two fields: an enum to indicate the direction of
the signal in the modport, and a symbol reference to refer to the signal.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span><span class=s>&#34;input&#34;</span> <span class=nf>@data</span><span class=p>)</span>
sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span><span class=s>&#34;output&#34;</span> <span class=nf>@data</span><span class=p>)</span>
</code></pre></div><p>Traits: HasParent<interfaceop></p><p>Interfaces: Symbol</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>ports</code></td><td align=center>::mlir::ArrayAttr</td><td>array of modport structs</td></tr></tbody></table><h3 id=svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)&nbsp;<a class=headline-hash href=#svinterface-circtsvinterfaceop>¶</a></h3><p>Operation to define a SystemVerilog interface</p><p>Syntax:</p><pre><code>operation ::= `sv.interface` attr-dict $sym_name $body
</code></pre><p>This operation defines a named interface. Its name is a symbol that can
be looked up when declared inside a SymbolTable operation. This operation is
also a SymbolTable itself, so the symbols in its region can be looked up.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface <span class=nf>@myinterface</span> <span class=p>{</span>
  sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span><span class=s>&#34;input&#34;</span> <span class=nf>@data</span><span class=p>)</span>
  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span><span class=s>&#34;output&#34;</span> <span class=nf>@data</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Traits: NoTerminator, SingleBlock, SymbolTable</p><p>Interfaces: Symbol</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignal-circtsvinterfacesignalop>¶</a></h3><p>Operation to define a SystemVerilog signal for interfaces</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal` attr-dict $sym_name `:` $type
</code></pre><p>This operation defines a named signal within an interface. Its type is
specified in an attribute, and currently supports IntegerTypes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<interfaceop></p><p>Interfaces: Symbol</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>Any SV/HW type</td></tr></tbody></table><h3 id=svlocalparam-circtsvlocalparamop><code>sv.localparam</code> (::circt::sv::LocalParamOp)&nbsp;<a class=headline-hash href=#svlocalparam-circtsvlocalparamop>¶</a></h3><p>Declare a localparam</p><p>Syntax:</p><pre><code>operation ::= `sv.localparam` `:` type($result) custom&lt;ImplicitSSAName&gt;(attr-dict)
</code></pre><p>The localparam operation produces a <code>localparam</code> declaration. See SV spec
6.20.4 p125.</p><p>Traits: FirstAttrDerivedResultType</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)&nbsp;<a class=headline-hash href=#svpassign-circtsvpassignop>¶</a></h3><p>Nonblocking procedural assignment</p><p>Syntax:</p><pre><code>operation ::= `sv.passign` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog nonblocking procedural assignment statement &lsquo;x &lt;= y;'.
These occur in initial, always, task, and function blocks. The statement
can be scheduled without blocking procedural flow. See SV Spec 10.4.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)&nbsp;<a class=headline-hash href=#svread_inout-circtsvreadinoutop>¶</a></h3><p>Get the value of from something of inout type (e.g. a wire or inout port) as the value itself.</p><p>Syntax:</p><pre><code>operation ::= `sv.read_inout` $input attr-dict `:` type($input)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>InOutType</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignalread-circtsvreadinterfacesignalop>¶</a></h3><p>Access the data in an interface&rsquo;s signal.</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal.read` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              attr-dict `:` type($signalData)
</code></pre><p>This is an expression to access a signal inside of an interface.</p><pre><code>  %ifaceData = sv.interface.signal.read %iface
      (@handshake_example::@data) : i32
</code></pre><p>Could result in the following SystemVerilog:</p><pre><code>  wire [31:0] ifaceData = iface.data;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalData</code></td><td>any type</td></tr></tbody></table><h3 id=svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)&nbsp;<a class=headline-hash href=#svreg-circtsvregop>¶</a></h3><p>Define a new <code>reg</code> in SystemVerilog</p><p>Syntax:</p><pre><code>operation ::= `sv.reg` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict)
              `:` type($result)
</code></pre><p>Declare a SystemVerilog Variable Declaration of &lsquo;reg&rsquo; type.
See SV Spec 6.8, pp100.</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svrelease-circtsvreleaseop><code>sv.release</code> (::circt::sv::ReleaseOp)&nbsp;<a class=headline-hash href=#svrelease-circtsvreleaseop>¶</a></h3><p>Release procedural statement</p><p>Syntax:</p><pre><code>operation ::= `sv.release` $dest attr-dict `:` type($dest)
</code></pre><p>Release is used in conjunction with force. When released,
then if the variable does not currently have an active assign
procedural continuous assignment, the variable shall not immediately
change value. The variable shall maintain its current value until
the next procedural assignment or procedural continuous assignment
to the variable. Releasing a variable that currently has an
active assign procedural continuous assignment shall immediately
reestablish that assignment. See SV Spec 10.6.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr></tbody></table><h3 id=svstop-circtsvstopop><code>sv.stop</code> (::circt::sv::StopOp)&nbsp;<a class=headline-hash href=#svstop-circtsvstopop>¶</a></h3><p><code>$stop</code> system task</p><p>Syntax:</p><pre><code>operation ::= `sv.stop` $verbosity attr-dict
</code></pre><p>Causes the simulation to be suspended. Does not terminate the simulator.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: ProceduralOp</p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>verbosity</code></td><td align=center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></tbody></table><h3 id=svverbatimexpr-circtsvverbatimexprop><code>sv.verbatim.expr</code> (::circt::sv::VerbatimExprOp)&nbsp;<a class=headline-hash href=#svverbatimexpr-circtsvverbatimexprop>¶</a></h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre><code>operation ::= `sv.verbatim.expr` $string (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use sv.verbatim.expr.se) if you need them.</p><p>sv.verbatim.expr allows operand substitutions with {{0}} syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>symbols</code></td><td align=center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or InOutType</td></tr></tbody></table><h3 id=svverbatimexprse-circtsvverbatimexprseop><code>sv.verbatim.expr.se</code> (::circt::sv::VerbatimExprSEOp)&nbsp;<a class=headline-hash href=#svverbatimexprse-circtsvverbatimexprseop>¶</a></h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre><code>operation ::= `sv.verbatim.expr.se` $string (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is
allowed to have side effects.</p><p>sv.verbatim.se.expr allows operand substitutions with {{0}} syntax.</p><p>Interfaces: HasCustomSSAName</p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>symbols</code></td><td align=center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or InOutType</td></tr></tbody></table><h3 id=svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)&nbsp;<a class=headline-hash href=#svverbatim-circtsvverbatimop>¶</a></h3><p>Verbatim opaque text emitted inline.</p><p>Syntax:</p><pre><code>operation ::= `sv.verbatim` $string (`(` $operands^ `)` `:` type($operands))? attr-dict
</code></pre><p>This operation produces opaque text inline in the SystemVerilog output.</p><p>sv.verbatim allows operand substitutions with {{0}} syntax.</p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>symbols</code></td><td align=center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svwarning-circtsvwarningop><code>sv.warning</code> (::circt::sv::WarningOp)&nbsp;<a class=headline-hash href=#svwarning-circtsvwarningop>¶</a></h3><p><code>$warning</code> severity message task</p><p>Syntax:</p><pre><code>operation ::= `sv.warning` ($message^ (`(` $operands^ `)` `:` type($operands))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time warning.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)&nbsp;<a class=headline-hash href=#svwire-circtsvwireop>¶</a></h3><p>Define a new wire</p><p>Syntax:</p><pre><code>operation ::= `sv.wire` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict)
              `:` type($result)
</code></pre><p>Declare a SystemVerilog Net Declaration of &lsquo;wire&rsquo; type.
See SV Spec 6.7, pp97.</p><p>Traits: NonProceduralOp</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>inner_sym</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svxmr-circtsvxmrop><code>sv.xmr</code> (::circt::sv::XMROp)&nbsp;<a class=headline-hash href=#svxmr-circtsvxmrop>¶</a></h3><p>Encode a reference to a non-local net.</p><p>Syntax:</p><pre><code>operation ::= `sv.xmr` (`isRooted` $isRooted^)? custom&lt;XMRPath&gt;($path, $terminal) attr-dict `:` type($result)
</code></pre><p>This represents a non-local hierarchical name to a net, sometimes called a
cross-module reference. A hierarchical name may be absolute, when prefixed
with &lsquo;$root&rsquo;, in which case it is resolved from the set of top-level modules
(any non-instantiated modules). Non-absolute paths are resolved by
attempting resolution of the path locally, then recursively up the instance
graph. See SV Spec 23.6, pp721.</p><p>It is impossible to completely resolve a hierarchical name without making a
closed-world assumption in the compiler. We therefore don&rsquo;t try to link
hierarchical names to what they resolve to at compile time. A frontend
generating this op should ensure that any instance or object in the intended
path has public visibility so paths are not invalidated.</p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isRooted</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>path</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>terminal</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=interfacetype>InterfaceType&nbsp;<a class=headline-hash href=#interfacetype>¶</a></h3><p>SystemVerilog interface type pointing to an InterfaceOp</p><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>interface</td><td align=center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=modporttype>ModportType&nbsp;<a class=headline-hash href=#modporttype>¶</a></h3><p>SystemVerilog type pointing to an InterfaceModportOp</p><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>modport</td><td align=center><code>::mlir::SymbolRefAttr</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/HW/ title="'hw' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'hw' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/LLHD/ title="'llhd' Dialect">Next - 'llhd' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li class=active><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>