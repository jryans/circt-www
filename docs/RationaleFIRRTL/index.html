<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>FIRRTL Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/RationaleFIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>FIRRTL Dialect Rationale</h1><p>This document describes various design points of the FIRRTL dialect, why it is
the way it is, and current status and progress. This follows in the spirit of
other
<a href=https://mlir.llvm.org/docs/Rationale/>MLIR Rationale docs</a>
.</p><h2 id=introduction>Introduction&nbsp;<a class=headline-hash href=#introduction>¶</a></h2><p><a href=https://github.com/chipsalliance/firrtl>The FIRRTL project</a>
is an existing
open source compiler infrastructure used by the Chisel framework to lower &ldquo;.fir&rdquo;
files to Verilog. It provides a number of useful compiler passes and
infrastructure that allows the development of domain specific passes. The
FIRRTL project includes a
<a href=https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf>well documented IR
specification</a>
that explains the semantics of its IR, an
<a href=https://github.com/chipsalliance/firrtl/blob/master/src/main/antlr4/FIRRTL.g4>ANTLR
grammar</a>
includes some extensions beyond it, and a compiler implemented in Scala which we
refer to as the <em>Scala FIRRTL Compiler</em> (SFC).</p><p><em>The FIRRTL dialect in CIRCT is designed to provide a drop-in replacement for
the SFC for the subset of FIRRTL IR that is produced by Chisel and in common
use.</em> The FIRRTL dialect also provides robust support for SFC <em>Annotations</em>.</p><p>To achieve these goals, the FIRRTL dialect follows the FIRRTL IR specification
and the SFC implementation almost exactly. Where the FIRRTL specification
allows for undefined behavior, FIRRTL dialect and its passes will choose the SFC
interpretation of specific undefined behavior. The small deviations we do make
are discussed below. Early versions of the FIRRTL dialect made <em>heavy
deviations</em> from FIRRTL IR and the SFC (see the Type Canonicalization section
below). These deviations, while elegant, led to difficult to resolve mismatches
with the SFC and the inability to verify FIRRTL IR. The remaining small
deviations introduced in the FIRRTL dialect are done to simplify the CIRCT
implementation of a FIRRTL compiler and to take advantage of MLIR&rsquo;s various
features.</p><p>This document generally assumes that you&rsquo;ve read and have a basic grasp of the
FIRRTL IR spec, and it can be occasionally helpful to refer to the ANTLR
grammar.</p><h2 id=status>Status&nbsp;<a class=headline-hash href=#status>¶</a></h2><p>The FIRRTL dialect and FIR parser is a generally complete implementation of the
FIRRTL specification and is actively maintained, tracking new enhancements. The
FIRRTL dialect supports some undocumented features and the &ldquo;CHIRRTL&rdquo; flavor of
FIRRTL IR that is produced from Chisel. The FIRRTL dialect has support for
parsing an SFC Annotation file consisting of only local annotations and
converting this to operation or argument attributes. Non-local annotation
support is planned, but not implemented.</p><p>There are some exceptions to the above:</p><ol><li>We don&rsquo;t support the <code>Fixed</code> types for fixed point numbers, and some
primitives associated with them.</li><li>We don&rsquo;t support <code>Interval</code> types</li></ol><p>Some of these may be research efforts that didn&rsquo;t gain broad adoption, in which
case we don&rsquo;t want to support them. However, if there is a good reason and a
community that would benefit from adding support for these, we can do so.</p><h2 id=naming>Naming&nbsp;<a class=headline-hash href=#naming>¶</a></h2><p>One of the goals of the FIRRTL compiler is to produce human-readable Verilog
which can be easily mapped back to the input FIRRTL. Part of this effort
means that we want the naming of Verilog objects to match the names used in
the original FIRRTL, and they are predictably transformed during lowering.
For example, after bundles are replaced with scalars in the lower-types pass,
each field should be prefixed with the bundle name:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>circuit</span> <span class=nc>Example</span>
  <span class=n>module</span> <span class=nc>Example</span>
    <span class=n>reg</span> <span class=n>myreg</span><span class=k>:</span> <span class=o>{</span> <span class=kt>a</span> <span class=kt>:</span><span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=kt>b</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span><span class=o>,</span> <span class=n>clock</span>
<span class=o>;</span> <span class=n>firrtl</span><span class=o>-</span><span class=n>lower</span><span class=o>-</span><span class=n>types</span> <span class=k>=&gt;</span>
<span class=n>circuit</span> <span class=nc>Example</span>
  <span class=n>module</span> <span class=nc>Example</span>
    <span class=n>reg</span> <span class=n>myreg_a</span><span class=k>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=n>clock</span>
    <span class=n>reg</span> <span class=n>myreg_b</span><span class=k>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=n>clock</span>
</code></pre></div><p>The name transformations applied by the SFC have become part of the
documented API, and people rely on the final names to take a certain form.</p><p>There are names for temporaries generated by the Chisel and FIRRTL tooling
which are not important to maintain. These names are discarded when parsing,
which saves memory during compilation. New names are generated at Verilog
export time, which has the effect of renumbering intermediate value names.
Names generated by Chisel typically look like <code>_T_12</code>, and names generated by
the SFC look like <code>_GEN_12</code>. The FIRRTL compiler will not discard these names
if the object has an array attribute <code>annotations</code> containing the attribute
<code>{class = "firrtl.transforms.DontTouchAnnotation}</code>.</p><p>It is common for EDA tools to hide or optimize away entities which have a
name beginning with an <code>_</code>. FIRRTL considers these names precious (excluding
FIRRTL temporary names) and will maintain them.</p><h3 id=nonlocalanchor>NonLocalAnchor&nbsp;<a class=headline-hash href=#nonlocalanchor>¶</a></h3><p>In the <code>FIRRTL</code> dialect, only modules have a symbol on them and it might be
difficult to globally identify other operations like
<code>instance</code>, <code>wire</code>, <code>reg</code> or <code>mem</code>.
The NonLocalAnchor operation (<code>firrtl.nla</code>) can be used to identify the unique
instance of a <code>FIRRTL</code> operation globally.
<code>firrtl.nla</code> can be used to attach nonlocal annotations and also for metadata
emission.
<code>firrtl.nla</code> defines a symbol and contains a list of module symbols followed
by a list of instance names corresponding to each module.
For example, in the following example, <code>@nla_0</code> specifies instance
&ldquo;baz&rdquo; in module <code>@FooNL</code>, followed by instance
<code>"bar"</code> in module <code>@BazNL</code>, followed by
the wire named <code>"w"</code> in module <code>@BarNL</code>.</p><p><code>firrtl.nla</code> can define a unique instance path, and each element along the way
carries an annotation with class <code>circt. nonlocal</code>, which has a matching
<code>circt. nonlocal</code> field pointing to the global op.
Thus instances participating in nonlocal paths are readily apparent.</p><p>In the following example the <code>@nla_0</code> is used in the verbatim op
to capture the final Verilog name of the wire <code>w</code>.</p><p>The second <code>nla</code>, <code>@nla_1</code> doesn&rsquo;t specify the instance path and is anchored
on all instances of <code>@BarNL</code>.
This example shows that the <code>firrtl.nla</code> can be used to attach a symbol with
any operation.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir> firrtl<span class=p>.</span>circuit <span class=s>&#34;FooNL&#34;</span>   <span class=p>{</span>
    firrtl<span class=p>.</span>nla <span class=nf>@nla_0</span> <span class=p>[</span><span class=nf>@FooNL</span><span class=p>,</span> <span class=nf>@BazNL</span><span class=p>,</span> <span class=nf>@BarNL</span><span class=p>]</span> <span class=p>[</span><span class=s>&#34;baz&#34;</span><span class=p>,</span> <span class=s>&#34;bar&#34;</span><span class=p>,</span> <span class=s>&#34;w&#34;</span><span class=p>]</span>
    firrtl<span class=p>.</span>nla <span class=nf>@nla_1</span> <span class=p>[</span><span class=nf>@BarNL</span><span class=p>]</span> <span class=p>[</span><span class=s>&#34;w&#34;</span><span class=p>]</span> 
    firrtl<span class=p>.</span>module <span class=nf>@BarNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%w</span> <span class=p>=</span> firrtl<span class=p>.</span>wire  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla_0</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span><span class=p>,</span> <span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla_1</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span> <span class=p>]</span><span class=p>}</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint      
    <span class=p>}</span>
    firrtl<span class=p>.</span>module <span class=nf>@BazNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      firrtl<span class=p>.</span>instance bar  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla_0</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span><span class=p>]</span><span class=p>}</span> <span class=nf>@BarNL</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
    firrtl<span class=p>.</span>module <span class=nf>@FooNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      firrtl<span class=p>.</span>instance baz  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla_0</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span><span class=p>]</span><span class=p>}</span> <span class=nf>@BazNL</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>    
  <span class=p>}</span>

sv<span class=p>.</span>verbatim <span class=s>&#34;{{0}}&#34;</span> <span class=p>{</span> <span class=nl>symbols =</span> <span class=p>[</span><span class=nf>@nla_0</span><span class=p>]</span> <span class=p>}</span>
sv<span class=p>.</span>verbatim <span class=s>&#34;{{0}}&#34;</span> <span class=p>{</span> <span class=nl>symbols =</span> <span class=p>[</span><span class=nf>@nla_1</span><span class=p>]</span> <span class=p>}</span>
</code></pre></div><p>Following is an example of attaching non local annotations with a specific instance of the <code>wire</code> <code>w</code>.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>firrtl<span class=p>.</span>circuit <span class=s>&#34;FooNL&#34;</span>   <span class=p>{</span>
    firrtl<span class=p>.</span>nla <span class=nf>@nla_0</span> <span class=p>[</span><span class=nf>@FooNL</span><span class=p>,</span> <span class=nf>@BazNL</span><span class=p>,</span> <span class=nf>@BarNL</span><span class=p>]</span> <span class=p>[</span><span class=s>&#34;baz&#34;</span><span class=p>,</span> <span class=s>&#34;bar&#34;</span><span class=p>,</span> <span class=s>&#34;w&#34;</span><span class=p>]</span>
    
    firrtl<span class=p>.</span>module <span class=nf>@BarNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%w</span> <span class=p>=</span> firrtl<span class=p>.</span>wire  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla_0</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.test&#34;</span><span class=p>,</span> <span class=nl>nl =</span> <span class=s>&#34;nl&#34;</span><span class=p>}</span><span class=p>]</span><span class=p>}</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint    
    <span class=p>}</span>
    firrtl<span class=p>.</span>module <span class=nf>@BazNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      firrtl<span class=p>.</span>instance bar  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span><span class=p>]</span><span class=p>}</span> <span class=nf>@BarNL</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
    firrtl<span class=p>.</span>module <span class=nf>@FooNL</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
      firrtl<span class=p>.</span>instance baz  <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span><span class=p>{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}</span><span class=p>]</span><span class=p>}</span> <span class=nf>@BazNL</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
</code></pre></div><h2 id=type-system>Type system&nbsp;<a class=headline-hash href=#type-system>¶</a></h2><h3 id=not-using-standard-types>Not using standard types&nbsp;<a class=headline-hash href=#not-using-standard-types>¶</a></h3><p>At one point we tried to use the integer types in the standard dialect, like
<code>si42</code> instead of <code>!firrtl.sint&lt;42></code>, but we backed away from this. While it
originally seemed appealing to use those types, FIRRTL
operations generally need to work with &ldquo;unknown width&rdquo; integer types (i.e.
<code>!firrtl.sint</code>).</p><p>Having the known width and unknown width types implemented with two different
C++ classes was awkward, led to casting bugs, and prevented having a
<code>FIRRTLType</code> class that unified all the FIRRTL dialect types.</p><h3 id=not-canonicalizing-flip-types>Not Canonicalizing Flip Types&nbsp;<a class=headline-hash href=#not-canonicalizing-flip-types>¶</a></h3><p>An initial version of the FIRRTL dialect relied on canonicalization of flip
types according to the following rules:</p><ol><li><code>flip(flip(x))</code> == <code>x</code>.</li><li><code>flip(analog(x))</code> == <code>analog(x)</code> since analog types are implicitly
bidirectional.</li><li><code>flip(bundle(a,b,c,d))</code> == <code>bundle(flip(a), flip(b), flip(c), flip(d))</code> when
the bundle has non-passive type or contains an analog type. This forces the
flip into the subelements, where it recursively merges with the non-passive
subelements and analogs.</li><li><code>flip(vector(a, n))</code> == <code>vector(flip(a), n)</code> when the vector has non-passive
type or analogs. This forces the flip into the element type, generally
canceling it out.</li><li><code>bundle(flip(a), flip(b), flip(c), flip(d))</code> == <code>flip(bundle(a, b, c, d)</code>.
Due to the other rules, the operand to a flip must be a passive type, so the
entire bundle will be passive, and rule #3 won&rsquo;t be recursively reinvoked.</li></ol><p>While elegant in a number of ways (e.g., FIRRTL types are guaranteed to have a
canonical representation and can be compared using pointer equality, flips
partially subsume port directionality and &ldquo;flow&rdquo;, and analog inputs and outputs
are canonicalized to the same representation), this resulted in information loss
during canonicalization because the number of flip types can change. Namely,
three problems were identified:</p><ol><li>Type canonicalization may make illegal operations legal.</li><li>The flow of connections could not be verified because flow is a function of
the number of flip types.</li><li>The directionality of leaves in an aggregate could not be determined.</li></ol><p>As an example of the first problem, consider the following circuit:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Foo</span><span class=k>:</span>
  <span class=kt>output</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>
  <span class=kt>output</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>

  <span class=kt>b</span> <span class=kt>&lt;=</span> <span class=kt>a</span>
</code></pre></div><p>The connection <code>b &lt;= a</code> <em>is illegal</em> FIRRTL due to a type mismatch where <code>{ flip a: UInt&lt;1> }</code> is not equal to <code>{ a: UInt&lt;1> }</code>. However, type canonicalization
would transform this circuit into the following circuit:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Foo</span><span class=k>:</span>
  <span class=kt>input</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>
  <span class=kt>output</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>

  <span class=kt>b</span> <span class=kt>&lt;=</span> <span class=kt>a</span>
</code></pre></div><p>Here, the connection <code>b &lt;= a</code> <em>is legal</em> FIRRTL. This then makes it impossible
for a type canonical form to be type checked.</p><p>As an example of the second problem, consider the following circuit:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Bar</span><span class=k>:</span>
  <span class=kt>output</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>
  <span class=kt>input</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>flip</span> <span class=kt>b</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>

  <span class=kt>b</span> <span class=kt>&lt;=</span> <span class=kt>a</span>
</code></pre></div><p>Here, the connection <code>b &lt;= a</code> <em>is illegal</em> FIRRTL because <code>b</code> is a source and
<code>a</code> is a sink. However, type canonicalization converts this to the following
circuit:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Bar</span><span class=k>:</span>
  <span class=kt>input</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>
  <span class=kt>output</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>b</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>

  <span class=kt>b</span> <span class=kt>&lt;=</span> <span class=kt>a</span>
</code></pre></div><p>Here, the connect <code>b &lt;= a</code> <em>is legal</em> FIRRTL because <code>b</code> is now a sink and <code>a</code>
is now a source. This then makes it impossible for a type canonical form to be
flow checked.</p><p>As an example of the third problem, consider the following circuit:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Baz</span><span class=k>:</span>
  <span class=kt>wire</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>}</span><span class=o>}</span>
  <span class=kt>wire</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span><span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>flip</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>}</span><span class=o>}</span>

  <span class=kt>b</span><span class=kt>.</span><span class=kt>a</span> <span class=kt>&lt;=</span> <span class=kt>a.a</span>
</code></pre></div><p>The connection <code>b.a &lt;= a.a</code>, when lowered, results in the <em>reverse</em> connect
<code>a.a.a &lt;= b.a.a</code>. However, type canonicalization will remove the flips from the
circuit to produce:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Baz</span><span class=k>:</span>
  <span class=kt>wire</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>}</span><span class=o>}</span>
  <span class=kt>wire</span> <span class=kt>b</span><span class=kt>:</span> <span class=o>{</span><span class=kt>a</span><span class=kt>:</span> <span class=o>{</span><span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>}</span><span class=o>}</span>

  <span class=kt>b</span><span class=kt>.</span><span class=kt>a</span> <span class=kt>&lt;=</span> <span class=kt>a.a</span>
</code></pre></div><p>Here, the connect <code>b.a &lt;= a.a</code>, when lowered, results in the normal connect
<code>b.a.a &lt;= a.a.a</code>. Type canonicalization has thereby changed the semantics of
connect.</p><p>Due to the elegance of type canonicalization, we initially decided that we would
use type canonicalization and CIRCT would accept more circuits than the SFC.
The third problem (identified much later than the first two) convinced us to
remove type canonicalization.</p><p>For a historical discussion of type canonicalization see:</p><ul><li><a href=https://github.com/llvm/circt/issues/380><code>llvm/circt#380</code></a></li><li><a href=https://github.com/llvm/circt/issues/919><code>llvm/circt#919</code></a></li><li><a href=https://github.com/llvm/circt/pull/944><code>llvm/circt#944</code></a></li></ul><h3 id=flow>Flow&nbsp;<a class=headline-hash href=#flow>¶</a></h3><p>The FIRRTL specification describes the concept of &ldquo;flow&rdquo;. Flow encodes
additional information that determines the legality of operations. FIRRTL
defines three different flows: <code>sink</code>, <code>source</code>, and <code>duplex</code>. Module inputs,
instance outputs, and nodes are <code>source</code>, module outputs and instance inputs are
<code>sink</code>, and wires and registers are <code>duplex</code>. A value with <code>sink</code> flow may only
be written to, but not read from (with the exception of module outputs and
instance inputs which may be also read from). A value with <code>source</code> flow may be
read from, but not written to. A value with <code>duplex</code> flow may be read from or
written to.</p><p>For FIRRTL connects or partial connect statements, it follows that the
left-hand-side must be <code>sink</code> or <code>duplex</code> and the right-hand-side must be
<code>source</code>, <code>duplex</code>, or a port/instance <code>sink</code>.</p><p>Flow is <em>not</em> represented as a first-class type in CIRCT. We instead provide
utilities for computing flow when needed, e.g., for connect statement
verification.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=multiple-result-firrtlinstance-operation>Multiple result <code>firrtl.instance</code> operation&nbsp;<a class=headline-hash href=#multiple-result-firrtlinstance-operation>¶</a></h3><p>The FIRRTL spec describes instances as returning a bundle type, where each
element of the bundle corresponds to one of the ports of the module being
instanced. This makes sense in the Scala FIRRTL implementation, given that it
does not support multiple ports.</p><p>The MLIR FIRRTL dialect takes a different approach, having each element of the
bundle result turn into its own distinct result on the <code>firrtl.instance</code>
operation. This is made possible by MLIR&rsquo;s robust support for multiple value
operands, and makes the IR much easier to analyze and work with.</p><h3 id=module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs>Module bodies require def-before-use dominance instead of allowing graphs&nbsp;<a class=headline-hash href=#module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs>¶</a></h3><p>MLIR allows regions with arbitrary graphs in their bodies, and this is used by
the HW dialect to allow direct expression of cyclic graphs etc. While this
makes sense for hardware in general, the FIRRTL dialect is intended to be a
pragmatic infrastructure focused on lowering of Chisel code to the HW dialect,
it isn&rsquo;t intended to be a &ldquo;generally useful IR for hardware&rdquo;.</p><p>We recommend that non-Chisel frontends target the HW dialect, or a higher level
dialect of their own creation that lowers to HW as appropriate.</p><h3 id=input-and-output-module-ports><code>input</code> and <code>output</code> Module Ports&nbsp;<a class=headline-hash href=#input-and-output-module-ports>¶</a></h3><p>The FIRRTL specification describes two kinds of ports: <code>input</code> and <code>output</code>. In
the <code>firrtl.module</code> declaration we track this via an arbitrary precision integer
attribute (<code>IntegerAttr</code>) where each bit encodes the directionality of the port
at that index.</p><p>Originally, we encoded direction as the absence of an outer flip type (input) or
presence of an outer flip type (output). This was done as part of the original
type canonicalization effort which combined input/output with the type system.
However, once type canonicalization was removed flip type only became used in
three places: on the types of bundle fields, on the variadic return types of
instances or memories, and on ports. The first is the same as the FIRRTL
specification. The second is a deviation from the FIRRTL specification, but
allowable as it takes advantage of the MLIR&rsquo;s variadic capabilities to simplify
the IR. The third was an inelegant abuse of an unrelated concept that added
bloat to the type system. Many operations would have to check for an outer flip
on ports and immediately discard it.</p><p>For this reason, the <code>IntegerAttr</code> encoding implementation was chosen.</p><p>For a historical discussion of this issue and its development see:</p><ul><li><a href=https://github.com/llvm/circt/issues/989><code>llvm/circt#989</code></a></li><li><a href=https://github.com/llvm/circt/pull/992><code>llvm/circt#992</code></a></li></ul><h3 id=firrtlbitcast><code>firrtl.bitcast</code>&nbsp;<a class=headline-hash href=#firrtlbitcast>¶</a></h3><p>The bitcast operation represents a bitwise reinterpretation (cast) of a value.
It can be used to cast a vector or bundle type to an int type or vice-versa.
The bit width of input and result types must be known.
For an aggregate type, the bit width of every field must be known.
This always synthesizes away in hardware, and follows the same endianness
policy as <code>hw.bitcast</code>.</p><h3 id=firrtlmem><code>firrtl.mem</code>&nbsp;<a class=headline-hash href=#firrtlmem>¶</a></h3><p>Unlike the SFC, the FIRRTL dialect represents each memory port as a distinct
result value of the <code>firrtl.mem</code> operation. Also, the <code>firrtl.mem</code> node does
not allow zero port memories for simplicity. Zero port memories are dropped
by the .fir file parser.</p><h4 id=firrtlmem-attributes><code>firrtl.mem</code> Attributes&nbsp;<a class=headline-hash href=#firrtlmem-attributes>¶</a></h4><p>A <code>firrtl.mem</code> has the following properties</p><ol><li>Data type</li><li>Mask bitwidth</li><li>Depth</li><li>Name</li><li>Number of read ports, write ports, read-write ports</li><li>Read under write behavior</li><li>Read latency</li><li>Write latency</li></ol><h5 id=mask-bitwidth>Mask bitwidth&nbsp;<a class=headline-hash href=#mask-bitwidth>¶</a></h5><p>Any aggregate memory data type is lowered to ground type by the
<code>LowerTypes</code> pass. After lowering the data type, the data bitwidth must be
divisible by mask bitwidth. And we define the property granularity as:
<code>mask granularity = (Data bitwidth)/(Mask bitwidth)</code>.</p><p>Each mask bit can guard the write to <code>mask granularity</code> number of data bits.
For a single-bit mask, one-bit guards write to the data, hence
<code>mask granularity = data bitwidth</code>.</p><h4 id=macro-replacement>Macro replacement&nbsp;<a class=headline-hash href=#macro-replacement>¶</a></h4><p>Memories that satisfy the following conditions are candidates for macro replacement.</p><pre><code>1. read latency and write latency of one
2. only one readwrite port or write port
3. zero or one read port
4. undefined read-under-write behavior  
</code></pre><p>A memory generator defines the external module definition corresponding to the
memory for macro replacement. Memory generators need metadata to generate the
memory definition. SFC uses some metadata files to communicate with the
memory generators.
<code>&lt;design-name>.conf</code> is a file, that contains the metadata for the
memories which are under the &ldquo;design-under-test&rdquo; module hierarchy.
Following is a sample content of the file:</p><pre><code>   name SiFive_cc_dir_ext depth 512 width 248 ports mrw mask_gran 31
   name SiFive_cc_banks_0_ext depth 2048 width 72 ports rw
   name SiFive_PL2Cache_cc_banks_0_ext depth 2048 width 72 ports rw
</code></pre><ol><li><code>name</code> followed by the memory name.</li><li><code>depth</code> followed by the memory depth.</li><li><code>width</code> followed by the data bitwidth.</li><li><code>ports</code> followed by the <code>mrw</code> for read-write port,
<code>mwrite</code> for a write port and <code>read</code> for a read port.</li><li><code>mask_gran</code> followed by the mask granularity.</li></ol><h3 id=chirrtl-memories>CHIRRTL Memories&nbsp;<a class=headline-hash href=#chirrtl-memories>¶</a></h3><p>FIRRTL has two different representations of memories: Chisel <code>cmemory</code>
operations, <code>smem</code> and <code>cmem</code>, and the standard FIRRTL <code>mem</code> operation. Chisel
memory operations exist to make it easy to produce FIRRTL code from Chisel, and
closely match the Chisel API for memories. Chisel memories are intended to be
replaced with standard FIRRTL memories early in the pipeline. The set of
operations related to Chisel memories are often referred to as CHIRRTL.</p><p>The main difference between Chisel and FIRRTL memories is that Chisel memories
have an operation to add a memory port to a memory, while FIRRTL memories
require all ports to be defined up front. Another difference is that Chisel
memories have &ldquo;enable inferrence&rdquo;, and are usually inferred to be enabled where
they are declared. The following example shows a CHIRRTL memory declaration,
and the standard FIRRTL memory equivalent.</p><pre><code class=language-firrtl data-lang=firrtl>smem mymemory : UInt&lt;4&gt;[8]
when p:
  read mport port0 = mymemory[address], clock
</code></pre><pre><code class=language-firrtl data-lang=firrtl>mem mymemory:
    data-type =&gt; UInt&lt;4&gt;
    depth =&gt; 8
    read-latency =&gt; 0
    write-latency =&gt; 1
    reader =&gt; port0
    read-under-write =&gt; undefined

mymemory.port0.en &lt;= p
mymemory.port0.clk &lt;= clock
mymemory.port0.addr &lt;= address
</code></pre><p>FIRRTL memory operations were created because it was thought that a concrete
memory primitive, that looks like an instance, is a better design for a
compiler IR. It was originally intended that Chisel would be modified to emit
FIRRTL memory operations directly, and the CHIRRTL operations would be retired.
The lowering from Chisel memories to FIRRTL memories proved far more
complicated than originally envisioned, specifically surrounding the type of
ports, inference of enable signals, and inference of clocks.</p><p>CHIRRTL operations have since stuck around, but their strange behavior has lead
to discussions to remove, improve, or totally redesign them. For some current
discussion about this see <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Since CIRCT is attempting to be a drop in
replacement FIRRTL compiler, we are not attempting to implement these new ideas
for Chisel memories. Instead, we are trying to implement what exists today.</p><p>There is, however, a major compatibility issue with the existing implementation
of Chisel memories which made them difficult to support in CIRCT. The FIRRTL
specification disallows using any declaration outside of the scope where it is
created. This means that a Chisel memory port declared inside of a <code>when</code>
block can only be used inside the scope of the <code>when</code> block. Unfortunately,
this invariant is not enforced for memory ports, and this leniency has been
abused by the Chisel standard library. Due to the way clock and enable
inference works, we couldn&rsquo;t just hoist the declaration into the outer scope.</p><p>To support escaping memory port definitions, we decided to split the memory
port operation into two operations. We created a <code>firrtl.memoryport</code> operation
to declare the memory port, and a <code>firrtl.memoryport.access</code> operation to
enable the memory port. The following is an example of how FIRRTL translates
into the CIRCT dialect:</p><pre><code class=language-firrtl data-lang=firrtl>smem mymem : UInt&lt;1&gt;[8]
when cond:
  infer mport myport = mymem[addr], clock
out &lt;= myport
</code></pre><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%mymem</span> <span class=p>=</span> firrtl<span class=p>.</span>seqmem Undefined  <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>8</span><span class=p>&gt;</span>
<span class=nv>%myport_data</span><span class=p>,</span> <span class=nv>%myport_port</span> <span class=p>=</span> firrtl<span class=p>.</span>memoryport Infer <span class=nv>%mymem</span> <span class=p>{</span><span class=nl>name =</span> <span class=s>&#34;myport&#34;</span><span class=p>}</span>  <span class=p>:</span> <span class=p>(</span><span class=p>!</span>firrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>cmemoryport<span class=p>)</span>
firrtl<span class=p>.</span>when <span class=nv>%cond</span>  <span class=p>{</span>
  firrtl<span class=p>.</span>memoryport<span class=p>.</span>access <span class=nv>%myport_port</span><span class=p>[</span><span class=nv>%addr</span><span class=p>]</span><span class=p>,</span> <span class=nv>%clock</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>cmemoryport<span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>clock
<span class=p>}</span>
firrtl<span class=p>.</span>connect <span class=nv>%out</span><span class=p>,</span> <span class=nv>%myport_data</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span>
</code></pre></div><p>For a historical discussion of this issue and its development see
<a href=https://github.com/llvm/circt/issues/1561><code>llvm/circt#1561</code></a>
.</p><h3 id=more-things-are-represented-as-primitives>More things are represented as primitives&nbsp;<a class=headline-hash href=#more-things-are-represented-as-primitives>¶</a></h3><p>We describe the <code>mux</code> expression as &ldquo;primitive&rdquo;, whereas the IR
spec and grammar implement it as a special kind of expression.</p><p>We do this to simplify the implementation: These expressions
have the same structure as primitives, and modeling them as such allows reuse
of the parsing logic instead of duplication of grammar rules.</p><h3 id=invalid-invalidate-operation-is-an-expression><code>invalid</code> Invalidate Operation is an expression&nbsp;<a class=headline-hash href=#invalid-invalidate-operation-is-an-expression>¶</a></h3><p>The FIRRTL spec describes an <code>x is invalid</code> statement that logically computes
an invalid value and connects it to <code>x</code> according to flow semantics. This
behavior makes analysis and transformation a bit more complicated, because there
are now two things that perform connections: <code>firrtl.connect</code> and the
<code>x is invalid</code> operation.</p><p>To make things easier to reason about, we split the <code>x is invalid</code> operation
into two different ops: an <code>firrtl.invalidvalue</code> op that takes no operands
and returns an invalid value, and a standard <code>firrtl.connect</code> operation that
connects the invalid value to the destination (or a <code>firrtl.attach</code> for analog
values). This has the same expressive power as the standard FIRRTL
representation but is easier to work with.</p><p>During parsing, we break up an <code>x is invalid</code> statement into leaf connections.
As an example, consider the following FIRRTL module where a bi-directional
aggregate, <code>a</code> is invalidated:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>module</span> <span class=nc>Foo</span><span class=k>:</span>
  <span class=kt>output</span> <span class=kt>a</span><span class=kt>:</span> <span class=o>{</span> <span class=kt>a</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=kt>flip</span> <span class=kt>b</span><span class=kt>:</span> <span class=kt>UInt</span><span class=kt>&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>}</span>

  <span class=n>a</span> <span class=n>is</span> <span class=n>invalid</span>
</code></pre></div><p>This is parsed into the following MLIR. Here, only <code>a.a</code> is invalidated:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>firrtl<span class=p>.</span>module <span class=nf>@Foo</span><span class=p>(</span>out <span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>bundle<span class=p>&lt;</span>a<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> b<span class=p>:</span> flip<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>subfield <span class=nv>%a</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>firrtl<span class=p>.</span>bundle<span class=p>&lt;</span>a<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> b<span class=p>:</span> flip<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
  <span class=nv>%invalid_ui1</span> <span class=p>=</span> firrtl<span class=p>.</span>invalidvalue <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
  firrtl<span class=p>.</span>connect <span class=nv>%0</span><span class=p>,</span> <span class=nv>%invalid_ui1</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><h3 id=validif-represented-as-a-multiplexer><code>validif</code> represented as a multiplexer&nbsp;<a class=headline-hash href=#validif-represented-as-a-multiplexer>¶</a></h3><p>The FIRRTL spec describes a <code>validif(en, x)</code> operation that is used during lowering from high to low FIRRTL. Consider the following example:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>c</span> <span class=o>&lt;=</span> <span class=n>invalid</span>
<span class=n>when</span> <span class=n>a</span><span class=k>:</span>
  <span class=kt>c</span> <span class=kt>&lt;=</span> <span class=kt>b</span>
</code></pre></div><p>Lowering will introduce the following intermediate representation in low FIRRTL:</p><div class=highlight><pre class=chroma><code class=language-scala data-lang=scala><span class=n>c</span> <span class=o>&lt;=</span> <span class=n>validif</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span>
</code></pre></div><p>Since there is no precedence of this <code>validif</code> being used anywhere in the Chisel/FIRRTL ecosystem thus far and instead is always replaced by its right-hand operand <code>b</code>, the FIRRTL MLIR dialect does not provide such an operation at all. Rather it directly replaces any <code>validif</code> in FIRRTL input with the following equivalent operations:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>invalidvalue <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>42</span><span class=p>&gt;</span>
<span class=nv>%c</span> <span class=p>=</span> firrtl<span class=p>.</span>mux<span class=p>(</span><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>42</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>42</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>42</span><span class=p>&gt;</span>
</code></pre></div><p>A canonicalization then folds this combination of <code>firrtl.invalidvalue</code> and <code>firrtl.mux</code> to the &ldquo;high&rdquo; operand of the multiplexer to facilitate downstream transformation passes.</p><h3 id=inline-systemverilog-through-verbatimexpr-operation>Inline SystemVerilog through <code>verbatim.expr</code> operation&nbsp;<a class=headline-hash href=#inline-systemverilog-through-verbatimexpr-operation>¶</a></h3><p>The FIRRTL dialect offers a <code>firrtl.verbatim.expr</code> operation that allows for SystemVerilog expressions to be embedded verbatim in the IR. It is lowered to the corresponding <code>sv.verbatim.expr</code> operation of the underlying SystemVerilog dialect, which embeds it in the emitted output. The operation has a FIRRTL result type, and a variadic number of operands can be accessed from within the inline SystemVerilog source text through string interpolation of <code>{{0}}</code>-style placeholders.</p><p>The rationale behind this verbatim operation is to offer an escape hatch analogous to <code>asm ("...")</code> in C/C++ and other languages, giving the user or compiler passes full control of what exactly gets embedded in the output. Usually, though, you would rather add a new operation to the IR to properly represent additional constructs.</p><p>As an example, a verbatim expression could be used to interact with yet-unsupported SystemVerilog constructs such as parametrized class typedef members:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>firrtl<span class=p>.</span>module <span class=nf>@Magic</span> <span class=p>(</span>out <span class=nv>%n</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>verbatim<span class=p>.</span>expr <span class=s>&#34;$bits(SomeClass #(.Param(1))::SomeTypedef)&#34;</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
  firrtl<span class=p>.</span>connect <span class=nv>%n</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>This would lower through the other dialects to SystemVerilog as you would expect:</p><div class=highlight><pre class=chroma><code class=language-systemverilog data-lang=systemverilog><span class=k>module</span> <span class=n>Magic</span> <span class=p>(</span><span class=k>output</span> <span class=p>[</span><span class=mh>31</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span> <span class=n>n</span><span class=p>)</span><span class=p>;</span>
  <span class=k>assign</span> <span class=n>n</span> <span class=o>=</span> <span class=n>$bits</span><span class=p>(</span><span class=n>SomeClass</span> <span class=p>#</span><span class=p>(</span><span class=p>.</span><span class=n>Param</span><span class=p>(</span><span class=mh>1</span><span class=p>)</span><span class=p>)</span><span class=o>:</span><span class=o>:</span><span class=n>SomeTypedef</span><span class=p>)</span><span class=p>;</span>
<span class=k>endmodule</span>
</code></pre></div><h2 id=interpretation-of-undefined-behavior>Interpretation of Undefined Behavior&nbsp;<a class=headline-hash href=#interpretation-of-undefined-behavior>¶</a></h2><p>The
<a href=https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf>FIRRTL
Specification</a>
has undefined behavior for certain features. When in doubt, FIRRTL dialect
<em>typically</em> chooses to implement undefined behavior in the same manner as the SFC.</p><h3 id=invalid>Invalid&nbsp;<a class=headline-hash href=#invalid>¶</a></h3><p>The SFC has a context-sensitive interpretation of invalid.</p><p>When an <code>is invalid</code> statement is used, the SFC will optimize this as a connect
to a constant zero if the invalidated component is not assigned to inside a
conditional block (<code>when</code>/<code>else</code>). <em>This is an interpretation of invalid as a
value that the compiler chooses to connect to a single component.</em></p><p>When an <code>is invalid</code> statement is used to specify the default of a component
that is connected to in a conditional block and the conditional block is not
complete, then a conditionally valid (<code>validif</code>) statement is generated. The
conditionally valid statement connects a value when a condition is true and
invalidates the component otherwise. (This is modeled as a multiplexer in the
FIRRTL dialect.) When lowered, the SFC treats this invalidation as undefined
behavior and will choose the valid path unconditionally. <em>This is an
interpretation of invalid as undefined behavior.</em> (See above for more
information on <code>validif</code> and the modeling of this as a multiplexer.)</p><p>Instead of choosing to aggressively optimize undefined behavior, FIRRTL dialect
and its passes use this context-sensitive interpretation of invalid. Folds of
primitive operations treat an invalid operand as a zero-valued constant. Folds
of multiplexers treat invalid operands as undefined behavior and will optimize
away the invalid path.</p><p>Propagation of invalid values is handled with extreme caution. Any propagation
can cause a later conflation of these two interpretations of invalid and produce
subtle bugs.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://github.com/chipsalliance/firrtl/issues/727>https://github.com/chipsalliance/firrtl/issues/727</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://github.com/chipsalliance/firrtl/pull/1821>https://github.com/chipsalliance/firrtl/pull/1821</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/FIRRTLAnnotations/ title="FIRRTL Annotations"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - FIRRTL Annotations</a>
<a class="nav nav-next" href=/docs/RationaleFSM/ title="FSM Dialect Rationale">Next - FSM Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'msft' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/HandshakePasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li class=active><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>