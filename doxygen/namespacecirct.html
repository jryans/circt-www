<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CIRCT: circt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CIRCT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">circt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecirct_1_1analysis"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1analysis.html">analysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1calyx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1calyx.html">calyx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1comb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1comb.html">comb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1esi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1esi.html">esi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ExportVerilog"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ExportVerilog.html">ExportVerilog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1firrtl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1firrtl.html">firrtl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1handshake"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1handshake.html">handshake</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1hw"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1hw.html">hw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1llhd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1llhd.html">llhd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1moore"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1moore.html">moore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1msft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1msft.html">msft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1scheduling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1scheduling.html">scheduling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1seq"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1seq.html">seq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1staticlogic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1staticlogic.html">staticlogic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1support"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1support.html">support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1sv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1sv.html">sv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1Backedge.html">Backedge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classcirct_1_1Backedge.html" title="Backedge is a wrapper class around a Value.">Backedge</a></code> is a wrapper class around a <code>Value</code>.  <a href="classcirct_1_1Backedge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BackedgeBuilder.html">BackedgeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate one of these and use it to build typed backedges.  <a href="classcirct_1_1BackedgeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BuildBBRegs.html">BuildBBRegs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds registers for each block argument in the program.  <a href="classcirct_1_1BuildBBRegs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BuildControl.html">BuildControl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control schedule by traversing the CFG of the function and associating this with the previously created groups.  <a href="classcirct_1_1BuildControl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BuildOpGroups.html">BuildOpGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through the operations of a source function and instantiate components or primitives based on the type of the operations.  <a href="classcirct_1_1BuildOpGroups.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BuildReturnRegs.html">BuildReturnRegs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds registers for the return statement of the program and constant assignments to the component return value.  <a href="classcirct_1_1BuildReturnRegs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BuildWhileGroups.html">BuildWhileGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In <a class="el" href="classcirct_1_1BuildWhileGroups.html" title="In BuildWhileGroups, a register is created for each iteration argumenet of the while op.">BuildWhileGroups</a>, a register is created for each iteration argumenet of the while op.  <a href="classcirct_1_1BuildWhileGroups.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1CalyxMemoryInterface.html">CalyxMemoryInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The various lowering passes are agnostic wrt.  <a href="structcirct_1_1CalyxMemoryInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1CalyxMemoryPorts.html">CalyxMemoryPorts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing a set of ports which act as a memory interface.  <a href="structcirct_1_1CalyxMemoryPorts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1CleanupFuncOps.html">CleanupFuncOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases FuncOp operations.  <a href="classcirct_1_1CleanupFuncOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1ConvertIndexTypes.html">ConvertIndexTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connverts all index-typed operations and values to i32 values.  <a href="classcirct_1_1ConvertIndexTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1EliminateUnusedCombGroups.html">EliminateUnusedCombGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes calyx::CombGroupOps which are unused.  <a href="structcirct_1_1EliminateUnusedCombGroups.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a reference to a specific field or element of an aggregate value.  <a href="classcirct_1_1FieldRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1FuncOpConversion.html">FuncOpConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Calyx component for each FuncOp in the program.  <a href="structcirct_1_1FuncOpConversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1FuncOpPartialLoweringPattern.html">FuncOpPartialLoweringPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FuncOpPartialLoweringPatterns are patterns which intend to match on FuncOps and then perform their own walking of the IR.  <a href="classcirct_1_1FuncOpPartialLoweringPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1InlineCombGroups.html">InlineCombGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass recursively inlines use-def chains of combinational logic (from non-stateful groups) into groups referenced in the control schedule.  <a href="classcirct_1_1InlineCombGroups.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1InlineExecuteRegionOpPattern.html">InlineExecuteRegionOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines Calyx ExecuteRegionOp operations within their parent blocks.  <a href="classcirct_1_1InlineExecuteRegionOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1LateSSAReplacement.html">LateSSAReplacement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcirct_1_1LateSSAReplacement.html" title="LateSSAReplacement contains various functions for replacing SSA values that were not replaced during ...">LateSSAReplacement</a> contains various functions for replacing SSA values that were not replaced during op construction.  <a href="classcirct_1_1LateSSAReplacement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1LoweringOptions.html">LoweringOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options which control the emission from CIRCT to Verilog.  <a href="structcirct_1_1LoweringOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1ModuleOpConversion.html">ModuleOpConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1MultipleGroupDonePattern.html">MultipleGroupDonePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When building groups which contain accesses to multiple sequential components, a group_done op is created for each of these.  <a href="structcirct_1_1MultipleGroupDonePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1NonTerminatingGroupDonePattern.html">NonTerminatingGroupDonePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GroupDoneOp's are terminator operations and should therefore be the last operator in a group.  <a href="structcirct_1_1NonTerminatingGroupDonePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1PartialLoweringPattern.html">PartialLoweringPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for partial lowering passes.  <a href="classcirct_1_1PartialLoweringPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1ProgramLoweringState.html">ProgramLoweringState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcirct_1_1ProgramLoweringState.html" title="ProgramLoweringState handles the current state of lowering of a Calyx program.">ProgramLoweringState</a> handles the current state of lowering of a Calyx program.  <a href="classcirct_1_1ProgramLoweringState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1RewriteMemoryAccesses.html">RewriteMemoryAccesses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass rewrites memory accesses that have a width mismatch.  <a href="classcirct_1_1RewriteMemoryAccesses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1SCFToCalyxPass.html">SCFToCalyxPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1WhileScheduleable.html">WhileScheduleable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac7c206087336cf641f1d3ae110a099ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac7c206087336cf641f1d3ae110a099ba">FuncMapping</a> = DenseMap&lt; FuncOp, calyx::ComponentOp &gt;</td></tr>
<tr class="memdesc:ac7c206087336cf641f1d3ae110a099ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping is maintained between a function operation and its corresponding Calyx component.  <a href="namespacecirct.html#ac7c206087336cf641f1d3ae110a099ba">More...</a><br /></td></tr>
<tr class="separator:ac7c206087336cf641f1d3ae110a099ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0db83a8f11d615b78a09e794e236ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aad0db83a8f11d615b78a09e794e236ea">Scheduleable</a> = std::variant&lt; calyx::GroupOp, <a class="el" href="structcirct_1_1WhileScheduleable.html">WhileScheduleable</a> &gt;</td></tr>
<tr class="memdesc:aad0db83a8f11d615b78a09e794e236ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of types representing scheduleable operations.  <a href="namespacecirct.html#aad0db83a8f11d615b78a09e794e236ea">More...</a><br /></td></tr>
<tr class="separator:aad0db83a8f11d615b78a09e794e236ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9435af881e5a5f5b7d2f38cabfe1a638"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a9435af881e5a5f5b7d2f38cabfe1a638">createAffineToStaticLogic</a> ()</td></tr>
<tr class="separator:a9435af881e5a5f5b7d2f38cabfe1a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8159eba1050168e2f366a77b9d927927"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a8159eba1050168e2f366a77b9d927927">createCalyxToHWPass</a> ()</td></tr>
<tr class="separator:a8159eba1050168e2f366a77b9d927927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15088c1b5bfd5c566c4b309a26458b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#adc15088c1b5bfd5c566c4b309a26458b">createExportVerilogPass</a> (llvm::raw_ostream &amp;os)</td></tr>
<tr class="separator:adc15088c1b5bfd5c566c4b309a26458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45dfc223465e0e8b4728b760adb2664"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad45dfc223465e0e8b4728b760adb2664">createExportVerilogPass</a> ()</td></tr>
<tr class="separator:ad45dfc223465e0e8b4728b760adb2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a14d3fb8514edda384b51998d7427"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a611a14d3fb8514edda384b51998d7427">createExportSplitVerilogPass</a> (llvm::StringRef directory=&quot;./&quot;)</td></tr>
<tr class="separator:a611a14d3fb8514edda384b51998d7427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190e54fae6bf3e6ba5ef813a09660599"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a190e54fae6bf3e6ba5ef813a09660599">exportVerilog</a> (mlir::ModuleOp module, llvm::raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a190e54fae6bf3e6ba5ef813a09660599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a module containing HW, and SV dialect code.  <a href="namespacecirct.html#a190e54fae6bf3e6ba5ef813a09660599">More...</a><br /></td></tr>
<tr class="separator:a190e54fae6bf3e6ba5ef813a09660599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952880b2424f3eb1eabf2fe2cd040420"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a952880b2424f3eb1eabf2fe2cd040420">exportSplitVerilog</a> (mlir::ModuleOp module, llvm::StringRef dirname)</td></tr>
<tr class="memdesc:a952880b2424f3eb1eabf2fe2cd040420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a module containing HW, and SV dialect code, as one file per SV module.  <a href="namespacecirct.html#a952880b2424f3eb1eabf2fe2cd040420">More...</a><br /></td></tr>
<tr class="separator:a952880b2424f3eb1eabf2fe2cd040420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff784244222f9103ad6bdc13bd51150"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1ff784244222f9103ad6bdc13bd51150">createLowerFIRRTLToHWPass</a> (bool enableAnnotationWarning=false, bool nonConstAsyncResetValueIsError=false)</td></tr>
<tr class="memdesc:a1ff784244222f9103ad6bdc13bd51150"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the pass constructor.  <a href="namespacecirct.html#a1ff784244222f9103ad6bdc13bd51150">More...</a><br /></td></tr>
<tr class="separator:a1ff784244222f9103ad6bdc13bd51150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f85a56e4acd6e17d4f4905d2310922"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a39f85a56e4acd6e17d4f4905d2310922">createHandshakeToFIRRTLPass</a> ()</td></tr>
<tr class="separator:a39f85a56e4acd6e17d4f4905d2310922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b2eb633f3a36e50550baeb8a5873f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a34b2eb633f3a36e50550baeb8a5873f8">createConvertHWToLLHDPass</a> ()</td></tr>
<tr class="memdesc:a34b2eb633f3a36e50550baeb8a5873f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HW to LLHD conversion pass.  <a href="namespacecirct.html#a34b2eb633f3a36e50550baeb8a5873f8">More...</a><br /></td></tr>
<tr class="separator:a34b2eb633f3a36e50550baeb8a5873f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc00eebc213425a364cbe8fb74279a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abbfc00eebc213425a364cbe8fb74279a">populateLLHDToLLVMConversionPatterns</a> (mlir::LLVMTypeConverter &amp;converter, RewritePatternSet &amp;patterns, size_t &amp;sigCounter, size_t &amp;regCounter)</td></tr>
<tr class="memdesc:abbfc00eebc213425a364cbe8fb74279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LLHD to LLVM conversion patterns.  <a href="namespacecirct.html#abbfc00eebc213425a364cbe8fb74279a">More...</a><br /></td></tr>
<tr class="separator:abbfc00eebc213425a364cbe8fb74279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f60207bf632c4712b4052f627a4dc2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a29f60207bf632c4712b4052f627a4dc2">createConvertLLHDToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a29f60207bf632c4712b4052f627a4dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an LLHD to LLVM conversion pass.  <a href="namespacecirct.html#a29f60207bf632c4712b4052f627a4dc2">More...</a><br /></td></tr>
<tr class="separator:a29f60207bf632c4712b4052f627a4dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa9ff05c0734850ae85e7aab67bc32fdc">createConvertMooreToCorePass</a> ()</td></tr>
<tr class="memdesc:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Moore to Comb/HW/LLHD conversion pass.  <a href="namespacecirct.html#aa9ff05c0734850ae85e7aab67bc32fdc">More...</a><br /></td></tr>
<tr class="separator:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb016225c004e9768edb7af6a0a5e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#acaeb016225c004e9768edb7af6a0a5e6">createSCFToCalyxPass</a> ()</td></tr>
<tr class="memdesc:acaeb016225c004e9768edb7af6a0a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an SCF to Calyx conversion pass.  <a href="namespacecirct.html#acaeb016225c004e9768edb7af6a0a5e6">More...</a><br /></td></tr>
<tr class="separator:acaeb016225c004e9768edb7af6a0a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa894b775b2e21df1a6adf14c639c3afe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa894b775b2e21df1a6adf14c639c3afe">createHandshakeAnalysisPass</a> ()</td></tr>
<tr class="separator:aa894b775b2e21df1a6adf14c639c3afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ff38838570d0ff568dd610dc2b53d8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a06ff38838570d0ff568dd610dc2b53d8">createHandshakeDataflowPass</a> ()</td></tr>
<tr class="separator:a06ff38838570d0ff568dd610dc2b53d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e04be8495987ff76ba0f791038512"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#af02e04be8495987ff76ba0f791038512">createHandshakeCanonicalizePass</a> ()</td></tr>
<tr class="separator:af02e04be8495987ff76ba0f791038512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2543765c582a73ac7918a35580c7df71"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a2543765c582a73ac7918a35580c7df71">createHandshakeRemoveBlockPass</a> ()</td></tr>
<tr class="separator:a2543765c582a73ac7918a35580c7df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f98f327e83e367a77d14474960e436a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4f98f327e83e367a77d14474960e436a">createHandshakeInsertBufferPass</a> ()</td></tr>
<tr class="separator:a4f98f327e83e367a77d14474960e436a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e617fb5667961db18f9974fe40ed293"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4e617fb5667961db18f9974fe40ed293">createCreatePipelinePass</a> ()</td></tr>
<tr class="separator:a4e617fb5667961db18f9974fe40ed293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369bfe3396c123b69c675513b443f04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a369bfe3396c123b69c675513b443f04f">registerAllDialects</a> (mlir::DialectRegistry &amp;registry)</td></tr>
<tr class="separator:a369bfe3396c123b69c675513b443f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5c0ad4bb681b1ea56e5baf3f6a3ba7b2">registerAllPasses</a> ()</td></tr>
<tr class="separator:a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175655b229eb86638ce75528ad53bc47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a175655b229eb86638ce75528ad53bc47">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a175655b229eb86638ce75528ad53bc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09e8956fca14d87a90ecda5067a59e2"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa09e8956fca14d87a90ecda5067a59e2">sextOrSelfZeroWidth</a> (APInt value, unsigned width)</td></tr>
<tr class="memdesc:aa09e8956fca14d87a90ecda5067a59e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safe version of APInt::sextOrSelf that will NOT assert on zero-width signed APSInts.  <a href="namespacecirct.html#aa09e8956fca14d87a90ecda5067a59e2">More...</a><br /></td></tr>
<tr class="separator:aa09e8956fca14d87a90ecda5067a59e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a53b9396aa3980bc8f79596626db5d"><td class="memItemLeft" align="right" valign="top">APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a51a53b9396aa3980bc8f79596626db5d">extOrTruncZeroWidth</a> (APSInt value, unsigned width)</td></tr>
<tr class="memdesc:a51a53b9396aa3980bc8f79596626db5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safe version of APSInt::extOrTrunc that will NOT assert on zero-width signed APSInts.  <a href="namespacecirct.html#a51a53b9396aa3980bc8f79596626db5d">More...</a><br /></td></tr>
<tr class="separator:a51a53b9396aa3980bc8f79596626db5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a65ce86f7290ab1b7e8dd11e3c6f18740">hash_value</a> (const <a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a> &amp;fieldRef)</td></tr>
<tr class="memdesc:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a hash code for a <a class="el" href="classcirct_1_1FieldRef.html" title="This class represents a reference to a specific field or element of an aggregate value.">FieldRef</a>.  <a href="namespacecirct.html#a65ce86f7290ab1b7e8dd11e3c6f18740">More...</a><br /></td></tr>
<tr class="separator:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a0ffbb9bb54c303e6b0d7a8602742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a6f9a0ffbb9bb54c303e6b0d7a8602742">registerLoweringCLOptions</a> ()</td></tr>
<tr class="memdesc:a6f9a0ffbb9bb54c303e6b0d7a8602742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register commandline options for the verilog emitter.  <a href="namespacecirct.html#a6f9a0ffbb9bb54c303e6b0d7a8602742">More...</a><br /></td></tr>
<tr class="separator:a6f9a0ffbb9bb54c303e6b0d7a8602742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc48743f3980835ac1300409ed02b6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abc48743f3980835ac1300409ed02b6c6">applyLoweringCLOptions</a> (ModuleOp module)</td></tr>
<tr class="memdesc:abc48743f3980835ac1300409ed02b6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any command line specified style options to the mlir module.  <a href="namespacecirct.html#abc48743f3980835ac1300409ed02b6c6">More...</a><br /></td></tr>
<tr class="separator:abc48743f3980835ac1300409ed02b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4941ed74ad92b2fabdad18da837748b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad4941ed74ad92b2fabdad18da837748b">appendPossiblyAbsolutePath</a> (llvm::SmallVectorImpl&lt; char &gt; &amp;base, const llvm::Twine &amp;suffix)</td></tr>
<tr class="memdesc:ad4941ed74ad92b2fabdad18da837748b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path to an existing path, replacing it if the other path is absolute.  <a href="namespacecirct.html#ad4941ed74ad92b2fabdad18da837748b">More...</a><br /></td></tr>
<tr class="separator:ad4941ed74ad92b2fabdad18da837748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd0bbd6f301e89241477a85244ff50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a83fd0bbd6f301e89241477a85244ff50">createFlattenMemRefPass</a> ()</td></tr>
<tr class="separator:a83fd0bbd6f301e89241477a85244ff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade81793059ca5b9b3f5d98d00691d5a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ade81793059ca5b9b3f5d98d00691d5a6">createFlattenMemRefCallsPass</a> ()</td></tr>
<tr class="separator:ade81793059ca5b9b3f5d98d00691d5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc188d8514568a623951ce6e2811e28"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#acfc188d8514568a623951ce6e2811e28">matchConstantOp</a> (Operation *op, APInt &amp;value)</td></tr>
<tr class="memdesc:acfc188d8514568a623951ce6e2811e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to match a constant value defined by op.  <a href="namespacecirct.html#acfc188d8514568a623951ce6e2811e28">More...</a><br /></td></tr>
<tr class="separator:acfc188d8514568a623951ce6e2811e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092131ceec4891a3909940211271ecd3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a092131ceec4891a3909940211271ecd3">singleLoadFromMemory</a> (Value memref)</td></tr>
<tr class="memdesc:a092131ceec4891a3909940211271ecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists only a single memref::LoadOp which loads from the memory referenced by loadOp.  <a href="namespacecirct.html#a092131ceec4891a3909940211271ecd3">More...</a><br /></td></tr>
<tr class="separator:a092131ceec4891a3909940211271ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1876d32068f72a7c515ea9a9d90f52"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a0e1876d32068f72a7c515ea9a9d90f52">noStoresToMemory</a> (Value memref)</td></tr>
<tr class="memdesc:a0e1876d32068f72a7c515ea9a9d90f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no memref::StoreOp uses with the referenced memory.  <a href="namespacecirct.html#a0e1876d32068f72a7c515ea9a9d90f52">More...</a><br /></td></tr>
<tr class="separator:a0e1876d32068f72a7c515ea9a9d90f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa552bdb96de208f1c4eaac89b29a3a02"><td class="memItemLeft" align="right" valign="top">static DictionaryAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa552bdb96de208f1c4eaac89b29a3a02">getMandatoryPortAttr</a> (MLIRContext *ctx, StringRef name)</td></tr>
<tr class="memdesc:aa552bdb96de208f1c4eaac89b29a3a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a DictionaryAttr containing a unit attribute 'name'.  <a href="namespacecirct.html#aa552bdb96de208f1c4eaac89b29a3a02">More...</a><br /></td></tr>
<tr class="separator:aa552bdb96de208f1c4eaac89b29a3a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd840589c1894fa5141a1a85fbceb5f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4dd840589c1894fa5141a1a85fbceb5f">addMandatoryComponentPorts</a> (PatternRewriter &amp;rewriter, SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;ports)</td></tr>
<tr class="memdesc:a4dd840589c1894fa5141a1a85fbceb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the mandatory Calyx component I/O ports (-&gt;[clk, reset, go], [done]-&gt;) to ports.  <a href="namespacecirct.html#a4dd840589c1894fa5141a1a85fbceb5f">More...</a><br /></td></tr>
<tr class="separator:a4dd840589c1894fa5141a1a85fbceb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a73fad49504693f27d826271c4ff24"><td class="memTemplParams" colspan="2">template&lt;typename TGroup &gt; </td></tr>
<tr class="memitem:a58a73fad49504693f27d826271c4ff24"><td class="memTemplItemLeft" align="right" valign="top">static TGroup&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a58a73fad49504693f27d826271c4ff24">createGroup</a> (PatternRewriter &amp;rewriter, calyx::ComponentOp compOp, Location loc, Twine uniqueName)</td></tr>
<tr class="memdesc:a58a73fad49504693f27d826271c4ff24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new calyx::CombGroupOp or calyx::GroupOp group within compOp.  <a href="namespacecirct.html#a58a73fad49504693f27d826271c4ff24">More...</a><br /></td></tr>
<tr class="separator:a58a73fad49504693f27d826271c4ff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312defe43dfbbf0e13a8b2cdd7ae652e"><td class="memItemLeft" align="right" valign="top">static Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a312defe43dfbbf0e13a8b2cdd7ae652e">getComponentOutput</a> (calyx::ComponentOp compOp, unsigned outPortIdx)</td></tr>
<tr class="memdesc:a312defe43dfbbf0e13a8b2cdd7ae652e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index'th output port of compOp.  <a href="namespacecirct.html#a312defe43dfbbf0e13a8b2cdd7ae652e">More...</a><br /></td></tr>
<tr class="separator:a312defe43dfbbf0e13a8b2cdd7ae652e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66f213c512b2b4029c67098e887e268"><td class="memItemLeft" align="right" valign="top">static Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad66f213c512b2b4029c67098e887e268">convIndexType</a> (PatternRewriter &amp;rewriter, Type type)</td></tr>
<tr class="memdesc:ad66f213c512b2b4029c67098e887e268"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an index type, converts it to i32, else, returns the unmodified type.  <a href="namespacecirct.html#ad66f213c512b2b4029c67098e887e268">More...</a><br /></td></tr>
<tr class="separator:ad66f213c512b2b4029c67098e887e268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db8cd9a3fb8a2dfe6d15c647804543"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a83db8cd9a3fb8a2dfe6d15c647804543">buildAssignmentsForRegisterWrite</a> (<a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;state, PatternRewriter &amp;rewriter, calyx::GroupOp groupOp, calyx::RegisterOp &amp;reg, Value inputValue)</td></tr>
<tr class="memdesc:a83db8cd9a3fb8a2dfe6d15c647804543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates register assignment operations within the provided groupOp.  <a href="namespacecirct.html#a83db8cd9a3fb8a2dfe6d15c647804543">More...</a><br /></td></tr>
<tr class="separator:a83db8cd9a3fb8a2dfe6d15c647804543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77974679f7decbfa9502cee0cd442a3"><td class="memItemLeft" align="right" valign="top">static calyx::GroupOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ab77974679f7decbfa9502cee0cd442a3">buildWhileIterArgAssignments</a> (PatternRewriter &amp;rewriter, <a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;state, Location loc, scf::WhileOp whileOp, Twine uniqueSuffix, ValueRange ops)</td></tr>
<tr class="separator:ab77974679f7decbfa9502cee0cd442a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a9ebbbaece82ca2a8c4b3d800ec9cb"><td class="memItemLeft" align="right" valign="top">static calyx::RegisterOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a03a9ebbbaece82ca2a8c4b3d800ec9cb">createReg</a> (<a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;compState, PatternRewriter &amp;rewriter, Location loc, Twine prefix, size_t width)</td></tr>
<tr class="memdesc:a03a9ebbbaece82ca2a8c4b3d800ec9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new register within the component associated to 'compState'.  <a href="namespacecirct.html#a03a9ebbbaece82ca2a8c4b3d800ec9cb">More...</a><br /></td></tr>
<tr class="separator:a03a9ebbbaece82ca2a8c4b3d800ec9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522affb9c10bec2775ba91358fb4d420"><td class="memTemplParams" colspan="2">template&lt;typename TAllocOp &gt; </td></tr>
<tr class="memitem:a522affb9c10bec2775ba91358fb4d420"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a522affb9c10bec2775ba91358fb4d420">buildAllocOp</a> (<a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;componentState, PatternRewriter &amp;rewriter, TAllocOp allocOp)</td></tr>
<tr class="separator:a522affb9c10bec2775ba91358fb4d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeef2a2c17ff92df42f8d57042b6b7cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#adeef2a2c17ff92df42f8d57042b6b7cc">appendPortsForExternalMemref</a> (PatternRewriter &amp;rewriter, StringRef memName, Value memref, SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;inPorts, SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;outPorts)</td></tr>
<tr class="separator:adeef2a2c17ff92df42f8d57042b6b7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac7c206087336cf641f1d3ae110a099ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c206087336cf641f1d3ae110a099ba">&#9670;&nbsp;</a></span>FuncMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecirct.html#ac7c206087336cf641f1d3ae110a099ba">circt::FuncMapping</a> = typedef DenseMap&lt;FuncOp, calyx::ComponentOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mapping is maintained between a function operation and its corresponding Calyx component. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00041">41</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

</div>
</div>
<a id="aad0db83a8f11d615b78a09e794e236ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0db83a8f11d615b78a09e794e236ea">&#9670;&nbsp;</a></span>Scheduleable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecirct.html#aad0db83a8f11d615b78a09e794e236ea">circt::Scheduleable</a> = typedef std::variant&lt;calyx::GroupOp, <a class="el" href="structcirct_1_1WhileScheduleable.html">WhileScheduleable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of types representing scheduleable operations. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00052">52</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4dd840589c1894fa5141a1a85fbceb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd840589c1894fa5141a1a85fbceb5f">&#9670;&nbsp;</a></span>addMandatoryComponentPorts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void circt::addMandatoryComponentPorts </td>
          <td>(</td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the mandatory Calyx component I/O ports (-&gt;[clk, reset, go], [done]-&gt;) to ports. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00129">129</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToCalyx_8cpp_source.html#l00121">getMandatoryPortAttr()</a>, <a class="el" href="CalyxOps_8h_source.html#l00063">circt::calyx::Input</a>, and <a class="el" href="CalyxOps_8h_source.html#l00063">circt::calyx::Output</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l01279">circt::FuncOpConversion::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="adeef2a2c17ff92df42f8d57042b6b7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeef2a2c17ff92df42f8d57042b6b7cc">&#9670;&nbsp;</a></span>appendPortsForExternalMemref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void circt::appendPortsForExternalMemref </td>
          <td>(</td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>memName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inPorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; <a class="el" href="structcirct_1_1calyx_1_1PortInfo.html">calyx::PortInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPorts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data</p>
<p>Done</p>
<p>Write data</p>
<p>Memory address outputs</p>
<p>Write enable</p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l01236">1236</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00039">circt::calyx::direction::get()</a>, <a class="el" href="CalyxOps_8h_source.html#l00063">circt::calyx::Input</a>, and <a class="el" href="CalyxOps_8h_source.html#l00063">circt::calyx::Output</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l01279">circt::FuncOpConversion::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="ad4941ed74ad92b2fabdad18da837748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4941ed74ad92b2fabdad18da837748b">&#9670;&nbsp;</a></span>appendPossiblyAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::appendPossiblyAbsolutePath </td>
          <td>(</td>
          <td class="paramtype">llvm::SmallVectorImpl&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Twine &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a path to an existing path, replacing it if the other path is absolute. </p>
<p>This mimicks the behaviour of <code>foo/bar</code> and <code>/foo/bar</code> being used in a working directory <code>/home</code>, resulting in <code>/home/foo/bar</code> and <code>/foo/bar</code>, respectively. </p>

<p class="definition">Definition at line <a class="el" href="Path_8cpp_source.html#l00023">23</a> of file <a class="el" href="Path_8cpp_source.html">Path.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l04355">createOutputFile()</a>, <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l03984">circt::ExportVerilog::SharedEmitterState::gatherFiles()</a>, and <a class="el" href="HWExportModuleHierarchy_8cpp_source.html#l00082">HWExportModuleHierarchyPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="abc48743f3980835ac1300409ed02b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc48743f3980835ac1300409ed02b6c6">&#9670;&nbsp;</a></span>applyLoweringCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::applyLoweringCLOptions </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any command line specified style options to the mlir module. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8cpp_source.html#l00155">155</a> of file <a class="el" href="LoweringOptions_8cpp_source.html">LoweringOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8cpp_source.html#l00151">clOptions</a>.</p>

</div>
</div>
<a id="a522affb9c10bec2775ba91358fb4d420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522affb9c10bec2775ba91358fb4d420">&#9670;&nbsp;</a></span>buildAllocOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllocOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult circt::buildAllocOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;&#160;</td>
          <td class="paramname"><em>componentState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00907">907</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00039">circt::calyx::direction::get()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l00187">circt::ComponentLoweringState::getComponentOp()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l00190">circt::ComponentLoweringState::getUniqueName()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l00359">circt::ComponentLoweringState::registerMemoryInterface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00929">circt::BuildOpGroups::buildOp()</a>.</p>

</div>
</div>
<a id="a83db8cd9a3fb8a2dfe6d15c647804543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db8cd9a3fb8a2dfe6d15c647804543">&#9670;&nbsp;</a></span>buildAssignmentsForRegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void circt::buildAssignmentsForRegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">calyx::GroupOp&#160;</td>
          <td class="paramname"><em>groupOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">calyx::RegisterOp &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>inputValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates register assignment operations within the provided groupOp. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00513">513</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToCalyx_8cpp_source.html#l00255">circt::ComponentLoweringState::getConstant()</a>, and <a class="el" href="seq_8py_source.html#l00015">seq::reg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00800">circt::BuildOpGroups::buildOp()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l00527">buildWhileIterArgAssignments()</a>.</p>

</div>
</div>
<a id="ab77974679f7decbfa9502cee0cd442a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77974679f7decbfa9502cee0cd442a3">&#9670;&nbsp;</a></span>buildWhileIterArgAssignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static calyx::GroupOp circt::buildWhileIterArgAssignments </td>
          <td>(</td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Location&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::WhileOp&#160;</td>
          <td class="paramname"><em>whileOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Twine&#160;</td>
          <td class="paramname"><em>uniqueSuffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueRange&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pass iteration arguments through registers. This follows closely to what is done for branch ops.</p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00527">527</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToCalyx_8cpp_source.html#l00513">buildAssignmentsForRegisterWrite()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l00187">circt::ComponentLoweringState::getComponentOp()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l00328">circt::ComponentLoweringState::getWhileIterReg()</a>, and <a class="el" href="seq_8py_source.html#l00015">seq::reg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00939">circt::BuildOpGroups::buildOp()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l01387">circt::BuildWhileGroups::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="ad66f213c512b2b4029c67098e887e268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66f213c512b2b4029c67098e887e268">&#9670;&nbsp;</a></span>convIndexType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Type circt::convIndexType </td>
          <td>(</td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the provided type is an index type, converts it to i32, else, returns the unmodified type. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00165">165</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l01088">circt::BuildOpGroups::buildOp()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l01159">circt::ConvertIndexTypes::PartiallyLowerFuncToComp()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l01279">circt::FuncOpConversion::PartiallyLowerFuncToComp()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l01483">circt::BuildReturnRegs::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="a9435af881e5a5f5b7d2f38cabfe1a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9435af881e5a5f5b7d2f38cabfe1a638">&#9670;&nbsp;</a></span>createAffineToStaticLogic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; mlir::circt::createAffineToStaticLogic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineToStaticLogic_8cpp_source.html#l00252">252</a> of file <a class="el" href="AffineToStaticLogic_8cpp_source.html">AffineToStaticLogic.cpp</a>.</p>

</div>
</div>
<a id="a8159eba1050168e2f366a77b9d927927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8159eba1050168e2f366a77b9d927927">&#9670;&nbsp;</a></span>createCalyxToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; mlir::circt::createCalyxToHWPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CalyxToHW_8cpp_source.html#l00058">58</a> of file <a class="el" href="CalyxToHW_8cpp_source.html">CalyxToHW.cpp</a>.</p>

</div>
</div>
<a id="a34b2eb633f3a36e50550baeb8a5873f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b2eb633f3a36e50550baeb8a5873f8">&#9670;&nbsp;</a></span>createConvertHWToLLHDPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertHWToLLHDPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HW to LLHD conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="HWToLLHD_8cpp_source.html#l00047">47</a> of file <a class="el" href="HWToLLHD_8cpp_source.html">HWToLLHD.cpp</a>.</p>

</div>
</div>
<a id="a29f60207bf632c4712b4052f627a4dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f60207bf632c4712b4052f627a4dc2">&#9670;&nbsp;</a></span>createConvertLLHDToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::circt::createConvertLLHDToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an LLHD to LLVM conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="LLHDToLLVM_8cpp_source.html#l02715">2715</a> of file <a class="el" href="LLHDToLLVM_8cpp_source.html">LLHDToLLVM.cpp</a>.</p>

</div>
</div>
<a id="aa9ff05c0734850ae85e7aab67bc32fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ff05c0734850ae85e7aab67bc32fdc">&#9670;&nbsp;</a></span>createConvertMooreToCorePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertMooreToCorePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Moore to Comb/HW/LLHD conversion pass. </p>
<p>Create a Moore to core dialects conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="MooreToCore_8cpp_source.html#l00035">35</a> of file <a class="el" href="MooreToCore_8cpp_source.html">MooreToCore.cpp</a>.</p>

</div>
</div>
<a id="a4e617fb5667961db18f9974fe40ed293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e617fb5667961db18f9974fe40ed293">&#9670;&nbsp;</a></span>createCreatePipelinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createCreatePipelinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardToStaticLogic_8cpp_source.html#l00122">122</a> of file <a class="el" href="StandardToStaticLogic_8cpp_source.html">StandardToStaticLogic.cpp</a>.</p>

</div>
</div>
<a id="a611a14d3fb8514edda384b51998d7427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a14d3fb8514edda384b51998d7427">&#9670;&nbsp;</a></span>createExportSplitVerilogPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;mlir::Pass&gt; circt::createExportSplitVerilogPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>directory</em> = <code>&quot;./&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad45dfc223465e0e8b4728b760adb2664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45dfc223465e0e8b4728b760adb2664">&#9670;&nbsp;</a></span>createExportVerilogPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportVerilogPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l04346">4346</a> of file <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html">ExportVerilog.cpp</a>.</p>

<p class="reference">References <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l04342">createExportVerilogPass()</a>.</p>

</div>
</div>
<a id="adc15088c1b5bfd5c566c4b309a26458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc15088c1b5bfd5c566c4b309a26458b">&#9670;&nbsp;</a></span>createExportVerilogPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportVerilogPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l04342">4342</a> of file <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html">ExportVerilog.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l04346">createExportVerilogPass()</a>.</p>

</div>
</div>
<a id="ade81793059ca5b9b3f5d98d00691d5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade81793059ca5b9b3f5d98d00691d5a6">&#9670;&nbsp;</a></span>createFlattenMemRefCallsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createFlattenMemRefCallsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00367">367</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a83fd0bbd6f301e89241477a85244ff50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fd0bbd6f301e89241477a85244ff50">&#9670;&nbsp;</a></span>createFlattenMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createFlattenMemRefPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00363">363</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a58a73fad49504693f27d826271c4ff24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a73fad49504693f27d826271c4ff24">&#9670;&nbsp;</a></span>createGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGroup &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TGroup circt::createGroup </td>
          <td>(</td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">calyx::ComponentOp&#160;</td>
          <td class="paramname"><em>compOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Location&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Twine&#160;</td>
          <td class="paramname"><em>uniqueName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new calyx::CombGroupOp or calyx::GroupOp group within compOp. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00146">146</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

</div>
</div>
<a id="aa894b775b2e21df1a6adf14c639c3afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa894b775b2e21df1a6adf14c639c3afe">&#9670;&nbsp;</a></span>createHandshakeAnalysisPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt;mlir::ModuleOp&gt; &gt; circt::createHandshakeAnalysisPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af02e04be8495987ff76ba0f791038512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e04be8495987ff76ba0f791038512">&#9670;&nbsp;</a></span>createHandshakeCanonicalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt;handshake::FuncOp&gt; &gt; circt::createHandshakeCanonicalizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06ff38838570d0ff568dd610dc2b53d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ff38838570d0ff568dd610dc2b53d8">&#9670;&nbsp;</a></span>createHandshakeDataflowPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::circt::createHandshakeDataflowPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardToHandshake_8cpp_source.html#l01659">1659</a> of file <a class="el" href="StandardToHandshake_8cpp_source.html">StandardToHandshake.cpp</a>.</p>

</div>
</div>
<a id="a4f98f327e83e367a77d14474960e436a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f98f327e83e367a77d14474960e436a">&#9670;&nbsp;</a></span>createHandshakeInsertBufferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt; mlir::circt::createHandshakeInsertBufferPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardToHandshake_8cpp_source.html#l01669">1669</a> of file <a class="el" href="StandardToHandshake_8cpp_source.html">StandardToHandshake.cpp</a>.</p>

</div>
</div>
<a id="a2543765c582a73ac7918a35580c7df71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2543765c582a73ac7918a35580c7df71">&#9670;&nbsp;</a></span>createHandshakeRemoveBlockPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt; mlir::circt::createHandshakeRemoveBlockPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardToHandshake_8cpp_source.html#l01664">1664</a> of file <a class="el" href="StandardToHandshake_8cpp_source.html">StandardToHandshake.cpp</a>.</p>

</div>
</div>
<a id="a39f85a56e4acd6e17d4f4905d2310922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f85a56e4acd6e17d4f4905d2310922">&#9670;&nbsp;</a></span>createHandshakeToFIRRTLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; mlir::circt::createHandshakeToFIRRTLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HandshakeToFIRRTL_8cpp_source.html#l02510">2510</a> of file <a class="el" href="HandshakeToFIRRTL_8cpp_source.html">HandshakeToFIRRTL.cpp</a>.</p>

</div>
</div>
<a id="a1ff784244222f9103ad6bdc13bd51150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff784244222f9103ad6bdc13bd51150">&#9670;&nbsp;</a></span>createLowerFIRRTLToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createLowerFIRRTLToHWPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableAnnotationWarning</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonConstAsyncResetValueIsError</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the pass constructor. </p>

<p class="definition">Definition at line <a class="el" href="LowerToHW_8cpp_source.html#l00388">388</a> of file <a class="el" href="LowerToHW_8cpp_source.html">LowerToHW.cpp</a>.</p>

</div>
</div>
<a id="a03a9ebbbaece82ca2a8c4b3d800ec9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a9ebbbaece82ca2a8c4b3d800ec9cb">&#9670;&nbsp;</a></span>createReg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static calyx::RegisterOp circt::createReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcirct_1_1ComponentLoweringState.html">ComponentLoweringState</a> &amp;&#160;</td>
          <td class="paramname"><em>compState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Location&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Twine&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new register within the component associated to 'compState'. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00579">579</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToCalyx_8cpp_source.html#l00187">circt::ComponentLoweringState::getComponentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00800">circt::BuildOpGroups::buildOp()</a>, <a class="el" href="SCFToCalyx_8cpp_source.html#l01387">circt::BuildWhileGroups::PartiallyLowerFuncToComp()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l01483">circt::BuildReturnRegs::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="acaeb016225c004e9768edb7af6a0a5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb016225c004e9768edb7af6a0a5e6">&#9670;&nbsp;</a></span>createSCFToCalyxPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createSCFToCalyxPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an SCF to Calyx conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l02159">2159</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

</div>
</div>
<a id="a952880b2424f3eb1eabf2fe2cd040420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952880b2424f3eb1eabf2fe2cd040420">&#9670;&nbsp;</a></span>exportSplitVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::exportSplitVerilog </td>
          <td>(</td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>dirname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a module containing HW, and SV dialect code, as one file per SV module. </p>
<p>Requires that the SV dialect is loaded in to the context.</p>
<p>Files are created in the directory indicated by <code>dirname</code>. </p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExportVerilog_2ExportVerilog_8cpp_source.html#l00024">mlirExportSplitVerilog()</a>.</p>

</div>
</div>
<a id="a190e54fae6bf3e6ba5ef813a09660599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190e54fae6bf3e6ba5ef813a09660599">&#9670;&nbsp;</a></span>exportVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::exportVerilog </td>
          <td>(</td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a module containing HW, and SV dialect code. </p>
<p>Requires that the SV dialect is loaded in to the context. </p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExportVerilog_2ExportVerilog_8cpp_source.html#l00017">mlirExportVerilog()</a>, and <a class="el" href="TranslateToVerilog_8cpp_source.html#l00472">circt::llhd::registerToVerilogTranslation()</a>.</p>

</div>
</div>
<a id="a51a53b9396aa3980bc8f79596626db5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a53b9396aa3980bc8f79596626db5d">&#9670;&nbsp;</a></span>extOrTruncZeroWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APSInt circt::extOrTruncZeroWidth </td>
          <td>(</td>
          <td class="paramtype">APSInt&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safe version of APSInt::extOrTrunc that will NOT assert on zero-width signed APSInts. </p>
<p>Instead of asserting, this will zero extend. </p>

<p class="definition">Definition at line <a class="el" href="APInt_8cpp_source.html#l00023">23</a> of file <a class="el" href="APInt_8cpp_source.html">APInt.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FIRRTLFolds_8cpp_source.html#l00103">getExtendedConstant()</a>.</p>

</div>
</div>
<a id="a312defe43dfbbf0e13a8b2cdd7ae652e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312defe43dfbbf0e13a8b2cdd7ae652e">&#9670;&nbsp;</a></span>getComponentOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value circt::getComponentOutput </td>
          <td>(</td>
          <td class="paramtype">calyx::ComponentOp&#160;</td>
          <td class="paramname"><em>compOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>outPortIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index'th output port of compOp. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00155">155</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l01483">circt::BuildReturnRegs::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
<a id="aa552bdb96de208f1c4eaac89b29a3a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa552bdb96de208f1c4eaac89b29a3a02">&#9670;&nbsp;</a></span>getMandatoryPortAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static DictionaryAttr circt::getMandatoryPortAttr </td>
          <td>(</td>
          <td class="paramtype">MLIRContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a DictionaryAttr containing a unit attribute 'name'. </p>
<p>Used for defining mandatory port attributes for calyx::ComponentOp's. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00121">121</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00039">circt::calyx::direction::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00129">addMandatoryComponentPorts()</a>.</p>

</div>
</div>
<a id="a65ce86f7290ab1b7e8dd11e3c6f18740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ce86f7290ab1b7e8dd11e3c6f18740">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code circt::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a hash code for a <a class="el" href="classcirct_1_1FieldRef.html" title="This class represents a reference to a specific field or element of an aggregate value.">FieldRef</a>. </p>

<p class="definition">Definition at line <a class="el" href="FieldRef_8h_source.html#l00074">74</a> of file <a class="el" href="FieldRef_8h_source.html">FieldRef.h</a>.</p>

<p class="reference">References <a class="el" href="FieldRef_8h_source.html#l00044">circt::FieldRef::getFieldID()</a>, and <a class="el" href="FieldRef_8h_source.html#l00037">circt::FieldRef::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FieldRef_8h_source.html#l00091">llvm::DenseMapInfo&lt; circt::FieldRef &gt;::getHashValue()</a>, <a class="el" href="DependenceIterator_8h_source.html#l00136">llvm::DenseMapInfo&lt; Dependence &gt;::getHashValue()</a>, and <a class="el" href="InferResets_8cpp_source.html#l00279">llvm::DenseMapInfo&lt; ResetSignal &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="acfc188d8514568a623951ce6e2811e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc188d8514568a623951ce6e2811e28">&#9670;&nbsp;</a></span>matchConstantOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool circt::matchConstantOp </td>
          <td>(</td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">APInt &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to match a constant value defined by op. </p>
<p>If the match was successful, returns true and binds the constant to 'value'. If unsuccessful, the value is unmodified. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00099">99</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l01007">circt::BuildOpGroups::buildOp()</a>.</p>

</div>
</div>
<a id="a0e1876d32068f72a7c515ea9a9d90f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1876d32068f72a7c515ea9a9d90f52">&#9670;&nbsp;</a></span>noStoresToMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool circt::noStoresToMemory </td>
          <td>(</td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there are no memref::StoreOp uses with the referenced memory. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00113">113</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00800">circt::BuildOpGroups::buildOp()</a>.</p>

</div>
</div>
<a id="abbfc00eebc213425a364cbe8fb74279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfc00eebc213425a364cbe8fb74279a">&#9670;&nbsp;</a></span>populateLLHDToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateLLHDToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sigCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>regCounter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the LLHD to LLVM conversion patterns. </p>

</div>
</div>
<a id="a369bfe3396c123b69c675513b443f04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369bfe3396c123b69c675513b443f04f">&#9670;&nbsp;</a></span>registerAllDialects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype">mlir::DialectRegistry &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00035">35</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

</div>
</div>
<a id="a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0ad4bb681b1ea56e5baf3f6a3ba7b2">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00031">31</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

<p class="reference">References <a class="el" href="PassRegistration_8cpp_source.html#l00020">circt::llhd::initLLHDTransformationPasses()</a>, <a class="el" href="ESIPasses_8cpp_source.html#l01310">circt::esi::registerESIPasses()</a>, <a class="el" href="MSFTPasses_8cpp_source.html#l00255">circt::msft::registerMSFTPasses()</a>, <a class="el" href="CIRCTModule_8cpp_source.html#l00029">registerPasses()</a>, and <a class="el" href="SeqPasses_8cpp_source.html#l00097">circt::seq::registerSeqPasses()</a>.</p>

</div>
</div>
<a id="a175655b229eb86638ce75528ad53bc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175655b229eb86638ce75528ad53bc47">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00029">29</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="ESITranslations_8cpp_source.html#l00183">circt::esi::registerESITranslations()</a>, <a class="el" href="FIRParser_8cpp_source.html#l03701">circt::firrtl::registerFromFIRFileTranslation()</a>, <a class="el" href="CalyxEmitter_8cpp_source.html#l00649">circt::calyx::registerToCalyxTranslation()</a>, <a class="el" href="FIREmitter_8cpp_source.html#l00801">circt::firrtl::registerToFIRFileTranslation()</a>, and <a class="el" href="TranslateToVerilog_8cpp_source.html#l00472">circt::llhd::registerToVerilogTranslation()</a>.</p>

</div>
</div>
<a id="a6f9a0ffbb9bb54c303e6b0d7a8602742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a0ffbb9bb54c303e6b0d7a8602742">&#9670;&nbsp;</a></span>registerLoweringCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerLoweringCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register commandline options for the verilog emitter. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8cpp_source.html#l00153">153</a> of file <a class="el" href="LoweringOptions_8cpp_source.html">LoweringOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8cpp_source.html#l00151">clOptions</a>.</p>

</div>
</div>
<a id="aa09e8956fca14d87a90ecda5067a59e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09e8956fca14d87a90ecda5067a59e2">&#9670;&nbsp;</a></span>sextOrSelfZeroWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt circt::sextOrSelfZeroWidth </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safe version of APInt::sextOrSelf that will NOT assert on zero-width signed APSInts. </p>
<p>Instead of asserting, this will zero extend. </p>

<p class="definition">Definition at line <a class="el" href="APInt_8cpp_source.html#l00018">18</a> of file <a class="el" href="APInt_8cpp_source.html">APInt.cpp</a>.</p>

</div>
</div>
<a id="a092131ceec4891a3909940211271ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092131ceec4891a3909940211271ecd3">&#9670;&nbsp;</a></span>singleLoadFromMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool circt::singleLoadFromMemory </td>
          <td>(</td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists only a single memref::LoadOp which loads from the memory referenced by loadOp. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l00105">105</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToCalyx_8cpp_source.html#l00800">circt::BuildOpGroups::buildOp()</a>, and <a class="el" href="SCFToCalyx_8cpp_source.html#l01791">circt::LateSSAReplacement::PartiallyLowerFuncToComp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 6 2021 00:16:51 for CIRCT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
